// parallax-hir/src/lower/expr.rs
// Lowers Typed AST expressions to ANF HIR expressions.

use super::*; // Import items from parent `mod.rs` (includes context, hir types, etc.)
use parallax_types::types::*;
use parallax_resolve::types::Symbol; // Use the public Symbol from resolve
use crate::hir::{HirExpr, HirExprKind, HirValue, HirTailExpr, Operand, HirType, HirFunction, HirFunctionSignature, HirVar, AggregateKind, HirLiteral, ProjectionKind, HirPattern, PrimitiveType}; // Added Hir PrimitiveType
use std::collections::{HashMap, HashSet};
use super::pattern::{lower_pattern_binding, lower_pattern};
use parallax_syntax::ast::common::Literal as AstLiteral;

// Type alias for binding data
type BindingData = (HirVar, HirType, HirValue);

/// Helper function to find a global constant/static initializer
/// (Placeholder implementation - assumes statics are handled elsewhere or simple)
fn find_const_global(symbol: &TypeSymbol, defs: &TypedDefinitions) -> Option<HirLiteral> {
    None  // Simply return None for now as a placeholder
}

/// Helper to lower a sub-expression to an operand, returning the operand
/// and the sequence of bindings required to compute it.
///
/// - `expr`: The sub-expression to lower.
/// - `ctx`: Lowering context.
/// - `defs`: Typed definitions.
/// - `bindings`: A mutable vector to accumulate the necessary let-bindings.
///
/// Returns the `Operand` representing the result of `expr`.
fn lower_sub_expr_to_operand<'def>(
    expr: &'def TypedExpr,
    ctx: &mut LoweringContext<'def>,
    defs: &'def TypedDefinitions,
    bindings: &mut Vec<BindingData> // Use BindingData type alias
) -> Operand {
    match &expr.kind {
        TypedExprKind::IntLiteral { value, suffix: _ } => {
            Operand::Const(lower_literal_with_type(&AstLiteral::Int { value: *value, suffix: None}, &expr.ty))
        }
        TypedExprKind::FloatLiteral { value, suffix: _ } => {
            Operand::Const(lower_literal_with_type(&AstLiteral::Float { value: *value, suffix: None}, &expr.ty))
        }
        TypedExprKind::StringLiteral(s) => Operand::Const(lower_literal_with_type(&AstLiteral::String(s.clone()), &expr.ty)),
        TypedExprKind::CharLiteral(c) => Operand::Const(lower_literal_with_type(&AstLiteral::Char(*c), &expr.ty)),
        TypedExprKind::BoolLiteral(b) => Operand::Const(lower_literal_with_type(&AstLiteral::Bool(*b), &expr.ty)),
        TypedExprKind::Variable { symbol, name } => {
            // Explicitly check for Symbol(0)
            if *symbol == Symbol(0) { // Use Symbol(0) directly
                 panic!("Lowering Error: Encountered invalid Symbol(0) ('{}') as a variable operand at {:?}.", name, expr.span);
            }

            if let Some(var) = ctx.get_hir_var(*symbol) {
                 Operand::Var(var)
             } else if defs.functions.contains_key(symbol) || defs.structs.contains_key(symbol) || defs.enums.contains_key(symbol) {
                 // Treat top-level functions, structs, enums as Globals referencing their symbol
                 Operand::Global(*symbol)
             } else if let Some(const_val) = find_const_global(symbol, defs) {
                 Operand::Const(const_val)
            } else {
                 // Assume it's a global function/method/enum variant symbol not found locally
                 // This covers trait methods like `Eq::ne` (Symbol(8))
                 println!("[Lowering Warning] Symbol '{}' ({:?}) not found in local context or global defs. Assuming it's a global symbol.", name, symbol);
                 Operand::Global(*symbol) 
             }
        }
        TypedExprKind::Paren(inner_expr) => {
            // Recurse
            lower_sub_expr_to_operand(inner_expr, ctx, defs, bindings)
        }
        // Complex cases: lower fully, bind result, return var
        _ => {
             // --- Final Approach: Use a helper that *returns* the value and bindings ---
            let (hir_value, new_bindings) = lower_to_value_and_bindings(ctx, expr, defs);

            // Add bindings generated by the sub-expression
            bindings.extend(new_bindings);

            // We only bind if the value isn't already a simple operand
            match hir_value {
                HirValue::Use(op) => op, // Already simple, use directly
                _ => { // Otherwise, create a binding for the computed value
                    let temp_var = ctx.fresh_hir_var();
                    let temp_var_ty = lower_type(&expr.ty, ctx);
                     // Push tuple instead of HirExprKind::Let
                     bindings.push((temp_var, temp_var_ty, hir_value));
                    Operand::Var(temp_var)
                }
            }
        }
    }
}

/// Lowers an expression to a HirValue, returning the value and any
/// bindings needed to compute its sub-expressions.
fn lower_to_value_and_bindings<'def>(
    ctx: &mut LoweringContext<'def>,
    expr: &'def TypedExpr,
    defs: &'def TypedDefinitions,
) -> (HirValue, Vec<BindingData>) { // Use BindingData type alias
    let mut bindings = Vec::new();
    let span = expr.span;

    let value = match &expr.kind {
        TypedExprKind::IntLiteral { value, .. } => HirValue::Use(Operand::Const(lower_literal_with_type(&AstLiteral::Int { value: *value, suffix: None}, &expr.ty))),
        TypedExprKind::FloatLiteral { value, .. } => HirValue::Use(Operand::Const(lower_literal_with_type(&AstLiteral::Float { value: *value, suffix: None}, &expr.ty))),
        TypedExprKind::StringLiteral(s) => HirValue::Use(Operand::Const(lower_literal_with_type(&AstLiteral::String(s.clone()), &expr.ty))),
        TypedExprKind::CharLiteral(c) => HirValue::Use(Operand::Const(lower_literal_with_type(&AstLiteral::Char(*c), &expr.ty))),
        TypedExprKind::BoolLiteral(b) => HirValue::Use(Operand::Const(lower_literal_with_type(&AstLiteral::Bool(*b), &expr.ty))),
        TypedExprKind::Variable { symbol, name: _ } => {
             // Use the same logic as lower_sub_expr_to_operand to determine if it's
             // global function, local var, global const, or param.
             if defs.functions.contains_key(symbol) {
                 HirValue::Use(Operand::Global(*symbol))
             } else if let Some(var) = ctx.get_hir_var(*symbol) {
                 HirValue::Use(Operand::Var(var))
             } else if let Some(const_val) = find_const_global(symbol, defs) {
                 HirValue::Use(Operand::Const(const_val))
             } else {
                 panic!("Lowering Error: Undefined variable {:?} used directly.", symbol);
             }
        }
        TypedExprKind::Paren(inner) => {
            // Recurse, add bindings, and return inner value.
            let (inner_value, inner_bindings) = lower_to_value_and_bindings(ctx, inner, defs);
            bindings.extend(inner_bindings); // Add bindings from the inner expression
            inner_value // Return only the value, bindings are added to the outer vector
        }
        TypedExprKind::Tuple(elements) => {
            let mut element_operands = Vec::with_capacity(elements.len());
            for elem_expr in elements {
                // Use lower_sub_expr_to_operand instead of the removed lower_to_operand
                let operand = lower_sub_expr_to_operand(elem_expr, ctx, defs, &mut bindings);
                element_operands.push(operand);
                // Removed push to binding_fns as lower_sub_expr_to_operand handles bindings directly
            }
            HirValue::Aggregate { kind: AggregateKind::Tuple, fields: element_operands }
        }
        TypedExprKind::Array(elements) => {
             let mut element_operands = Vec::with_capacity(elements.len());
            for elem_expr in elements {
                let operand = lower_sub_expr_to_operand(elem_expr, ctx, defs, &mut bindings);
                element_operands.push(operand);
            }
            HirValue::Aggregate { kind: AggregateKind::Array, fields: element_operands }
        }
         TypedExprKind::Struct { name, fields, base, struct_symbol } => {
            // 1. Lower base expression if present
            let mut base_operand_opt: Option<Operand> = None;
            if let Some(base_expr) = base {
                let base_operand = lower_sub_expr_to_operand(base_expr, ctx, defs, &mut bindings);
                base_operand_opt = Some(base_operand);
            }
            
            // Use the provided struct_symbol directly
            let struct_def_symbol = *struct_symbol;
                
            // Ensure the struct definition exists (sanity check)
            let struct_def = defs.structs.get(&struct_def_symbol)
                .unwrap_or_else(|| panic!("Could not find struct definition for symbol {:?} ('{}') during HIR value lowering", struct_def_symbol, name));

            // 2. Lower explicitly provided fields
            let mut explicit_field_values = HashMap::with_capacity(fields.len());
            for (fname, fexpr) in fields {
                let operand = lower_sub_expr_to_operand(fexpr, ctx, defs, &mut bindings);
                explicit_field_values.insert(fname.clone(), operand);
            }
            
            // 3. & 4. Initialize ordered operands and fill, projecting from base if needed
            let mut ordered_operands = Vec::with_capacity(struct_def.fields.len());
            
            for field_def in struct_def.fields.iter() { // Removed enumerate idx
                if let Some(explicit_operand) = explicit_field_values.get(&field_def.name) {
                    // Use explicitly provided value
                    ordered_operands.push(explicit_operand.clone());
                } else if let Some(ref base_op) = base_operand_opt {
                    // Project from the base operand
                    let projection_value = HirValue::Project {
                        base: base_op.clone(),
                        projection: ProjectionKind::Field(field_def.symbol),
                    };
                    // Bind the projection to a temp var
                    let temp_var = ctx.fresh_hir_var();
                    let temp_var_ty = lower_type(&field_def.ty, ctx); // Use type from struct def field
                    // Push tuple
                    bindings.push((temp_var, temp_var_ty, projection_value));
                    // Use the temp var as the operand for this field
                    ordered_operands.push(Operand::Var(temp_var));
                } else {
                    // Field not provided and no base expression - should be caught by type checker
                     panic!("Missing field '{}' for struct '{}' with no base expression", field_def.name, name);
                }
            }
            
            // 5. Construct Aggregate
             HirValue::Aggregate { kind: AggregateKind::Struct(struct_def_symbol), fields: ordered_operands }
         }
         TypedExprKind::VariantConstructor { enum_symbol, variant_symbol, args, enum_name: _, variant_name: _ } => {
             // Use the provided enum_symbol directly
             let enum_def_symbol = *enum_symbol;
             let enum_def = defs.enums.get(&enum_def_symbol)
                  .unwrap_or_else(|| panic!("Could not find enum definition for symbol {:?} during HIR value lowering", enum_def_symbol));
             
             // Use the provided variant_symbol directly
             let variant_symbol = *variant_symbol;
             let variant_def = enum_def.variants.iter()
                 .find(|v| v.symbol == variant_symbol) // Find variant by symbol
                 .unwrap_or_else(|| panic!("Could not find variant definition for symbol {:?} in enum {:?} during HIR value lowering", variant_symbol, enum_def_symbol));

             // Get expected arg count from the variant definition struct
             let expected_arg_count = variant_def.fields.len();

             if args.len() != expected_arg_count {
                  panic!("Arg count mismatch for variant constructor {:?} (expected {}, found {})", variant_symbol, expected_arg_count, args.len());
              }
             
             let mut arg_operands = Vec::with_capacity(args.len());
             for arg in args {
                 let operand = lower_sub_expr_to_operand(&arg.value, ctx, defs, &mut bindings);
                 arg_operands.push(operand);
             }
             HirValue::Aggregate { kind: AggregateKind::EnumVariant(variant_symbol), fields: arg_operands }
         }
          TypedExprKind::Field { object, field_name, field_symbol } => {
             let base_operand = lower_sub_expr_to_operand(object, ctx, defs, &mut bindings);
             let base_ty = lower_type(&object.ty, ctx);
             let projection_kind = match base_ty {
                 HirType::Adt(struct_symbol) => {
                      // Check if it's actually a struct
                      if defs.structs.contains_key(&struct_symbol) {
                          // Use the resolved field_symbol directly
                          ProjectionKind::Field(*field_symbol)
                      } else {
                          panic!("Field projection on non-struct ADT Symbol: {:?}", struct_symbol);
                      }
                 }
                 HirType::Tuple(element_types) => {
                     // Tuple field access uses index
                     let index: u32 = field_name.parse().unwrap_or_else(|_| panic!("Invalid tuple index: {}", field_name));
                      if index < element_types.len() as u32 {
                         ProjectionKind::TupleIndex(index)
                     } else {
                         panic!("Tuple index out of bounds: {}", index);
                     }
                 }
                 // --- Fix: Handle Array Indexing ---
                 HirType::Array(..) => {
                     // Array indexing requires the index to be an operand.
                     // If field_name parses as an integer, use that as a Const operand.
                     // Otherwise, assume field_symbol refers to the index variable.
                     match field_name.parse::<i128>() {
                         Ok(index_lit) => ProjectionKind::ArrayIndex(Operand::Const(HirLiteral::IntLiteral { value: index_lit, ty: PrimitiveType::I64 })),
                         Err(_) => {
                             // field_name is not a literal index, assume field_symbol is the index variable
                             if let Some(index_var) = ctx.get_hir_var(*field_symbol) {
                                 ProjectionKind::ArrayIndex(Operand::Var(index_var))
                             } else {
                                 // If field_symbol is also not a variable in context, it's an error.
                                 // This indicates a potential issue upstream (e.g., type checking or AST generation).
                                 panic!(
                                     "Lowering Error: Cannot lower array index. `field_name` ('{}') is not a literal index, and `field_symbol` ({:?}) is not a known variable in the current context.",
                                     field_name, field_symbol
                                 );
                             }
                         }
                     }
                 }
                 // --- End Fix ---
                 _ => panic!("Field projection on invalid base type: {:?}", base_ty),
             };
             HirValue::Project { base: base_operand, projection: projection_kind }
         }
         TypedExprKind::Call { func_expr, func_symbol, type_args: _, args } => {
            // --- START FIX ---
            // Prioritize the explicitly resolved func_symbol if available
            let func_operand = if let Some(resolved_symbol) = func_symbol {
                 // Ensure the symbol corresponds to a known function
                 if !defs.functions.contains_key(&resolved_symbol) {
                     // Print a warning if the function isn't found - could indicate an issue
                      println!("[Lowering Warning] Direct func_symbol {:?} not found in TypedDefinitions.functions", resolved_symbol);
                      // Fallback or panic? For now, let's proceed but this indicates an issue.
                 }
                 Operand::Global(*resolved_symbol)
            } else {
                 // Lower the function expression itself (indirect call, e.g., lambda)
                 lower_sub_expr_to_operand(func_expr, ctx, defs, &mut bindings)
            };
            // --- END FIX ---

            let mut arg_operands = Vec::with_capacity(args.len());
            for arg in args {
                 let arg_operand = lower_sub_expr_to_operand(&arg.value, ctx, defs, &mut bindings);
                 arg_operands.push(arg_operand);
             }
            HirValue::Call { func: func_operand, args: arg_operands }
         }
         TypedExprKind::Lambda { params, body } => {
             // 1. Analyze body for actual captures (free variables)
             let analyzed_captures = analyze_captures(ctx, body);
             let capture_operands: Vec<Operand> = analyzed_captures.iter().map(|(cap_symbol, _)| {
                if let Some(var) = ctx.get_hir_var(*cap_symbol) {
                    Operand::Var(var)
                 } else if defs.functions.contains_key(cap_symbol) {
                     Operand::Global(*cap_symbol)
                 } else if let Some(const_val) = find_const_global(cap_symbol, defs) {
                     Operand::Const(const_val)
                 } else {
                     panic!("Captured variable {:?} not found in outer scope", cap_symbol);
                 }
            }).collect();

            // 2. Generate symbol for the lambda's HirFunction
            let lambda_fn_symbol = ctx.fresh_symbol(); // Get a fresh symbol

            // 3. Generate the nested function definition if it doesn't exist
            // Check if a function with this *exact* signature and capture list already exists?
            // For now, generate eagerly based on symbol, DCE can remove duplicates later.
            // Extract params as Vec<(Symbol, Ty)> for generate_lambda_function
            let lambda_params_for_codegen: Vec<(Symbol, Ty)> = params.iter()
                .map(|p| (p.symbol, p.ty.clone()))
                .collect();
            
            // Generate the function eagerly. DCE pass will remove unused ones.
            let hir_function = generate_lambda_function(
                ctx, defs, lambda_fn_symbol, expr.span, 
                &lambda_params_for_codegen, // Pass the extracted params
                &analyzed_captures, body
            );
            ctx.generated_lambda_functions.push(hir_function);

            // 4. Create Closure value OR Global reference
            if analyzed_captures.is_empty() {
                // Optimize: Non-capturing lambda becomes a direct function pointer
                println!("[Lowering] Lambda {:?} has no captures, lowering to Global", lambda_fn_symbol);
                HirValue::Use(Operand::Global(lambda_fn_symbol))
            } else {
                // Capturing lambda requires a closure object
                 println!("[Lowering] Lambda {:?} has captures {:?}, lowering to Closure", lambda_fn_symbol, analyzed_captures);
                HirValue::Closure { function_symbol: lambda_fn_symbol, captures: capture_operands }
            }
         }
        // Handled by lower_sub_expr_to_operand
        TypedExprKind::Let {..} |
        TypedExprKind::If {..} |
        TypedExprKind::Match {..} => {
             // These should have been handled by the caller (`lower_expression`)
             // or by `lower_sub_expr_to_operand`. Reaching here suggests an issue.
             panic!("Unexpected control flow expression ({:?}) found inside lower_to_value_and_bindings.", expr.kind);
        }
        TypedExprKind::Block(..) => {
             // Similar to control flow, blocks should ideally be handled by `lower_expression`.
             panic!("Unexpected block expression found inside lower_to_value_and_bindings.");
        }
        TypedExprKind::Error => {
            // Decide how to handle errors. Maybe panic, maybe return a dummy value/node.
             panic!("Encountered TypedExprKind::Error during HIR lowering. Span: {:?}", expr.span);
        }
        TypedExprKind::Map(entries) => {
            // TODO: Lower map literal
            todo!("Lower Map literal")
        }
        TypedExprKind::HashSet(elements) => {
            // TODO: Lower hashset literal
            todo!("Lower HashSet literal")
        }
        TypedExprKind::LogicalAnd { left, right } => {
            // We don't handle this directly in lower_to_value_and_bindings
            // Desugar at lower_expression level by converting to an If expression
            panic!("LogicalAnd should be handled by lower_expression, not lower_to_value_and_bindings");
        }
        TypedExprKind::LogicalOr { left, right } => {
            // We don't handle this directly in lower_to_value_and_bindings
            // Desugar at lower_expression level by converting to an If expression
            panic!("LogicalOr should be handled by lower_expression, not lower_to_value_and_bindings");
        }
        TypedExprKind::TupleField { tuple, index } => {
            let base_operand = lower_sub_expr_to_operand(tuple, ctx, defs, &mut bindings);
            HirValue::Project { base: base_operand, projection: ProjectionKind::TupleIndex(*index as u32) }
        }
    };

    (value, bindings)
}

/// Main lowering function: Constructs the complete HirExpr.
pub(super) fn lower_expression<'def>(
    ctx: &mut LoweringContext<'def>,
    expr: &'def TypedExpr,
    defs: &'def TypedDefinitions,
) -> HirExpr {
    let span = expr.span;
    let final_hir_ty = lower_type(&expr.ty, ctx);

    match &expr.kind {
        // Let is handled specially here
        TypedExprKind::Let { pattern, value } => {
            let mut value_bindings = Vec::new();
            let value_operand = lower_sub_expr_to_operand(value, ctx, defs, &mut value_bindings);

            // pattern_bindings_data is Vec<(HirVar, HirType, HirValue)>
            let pattern_bindings = lower_pattern_binding(ctx, pattern, value_operand, defs);
            // Note: pattern_bindings are already in BindingData format: (HirVar, HirType, HirValue)

            // Assume Let expr evaluates to Unit if it's not the tail expr of a block/func.
            // This is handled correctly by the revised Block lowering.
            let body_expr = HirExpr {
                kind: HirExprKind::Tail(HirTailExpr::Value(Operand::Const(HirLiteral::Unit))),
                 ty: HirType::Tuple(vec![]), // Unit type
                 span, // Use Let's span for the implicit Unit return
             };

            let mut all_bindings = value_bindings;
            all_bindings.extend(pattern_bindings);

            // Construct the nested Let expression
            build_nested_lets(all_bindings, body_expr, span)
        }

        // --- Control Flow ---
        TypedExprKind::If { condition, then_branch, else_branch } => {
             let mut cond_bindings = Vec::new();
             let cond_operand = lower_sub_expr_to_operand(condition, ctx, defs, &mut cond_bindings);

             // Lower branches recursively
             let then_expr = lower_expression(ctx, then_branch, defs);
             let else_expr = match else_branch {
                 Some(else_b) => lower_expression(ctx, else_b, defs),
                 // If no else branch, it implicitly returns Unit.
                 None => HirExpr {
                     kind: HirExprKind::Tail(HirTailExpr::Value(Operand::Const(HirLiteral::Unit))),
                     ty: HirType::Tuple(vec![]), // Unit type
                     span: condition.span, // Span might need adjustment
                 }
             };

             // --- Always bind condition result ---
             let cond_var = ctx.fresh_hir_var();
             let cond_hir_ty = lower_type(&condition.ty, ctx); // Get condition's type
             cond_bindings.push((cond_var, cond_hir_ty, HirValue::Use(cond_operand)));
             // --- End Fix ---

             // Wrap the tail If expression with bindings for the condition
             let tail_if_expr = HirExpr {
                 kind: HirExprKind::Tail(HirTailExpr::If {
                     condition: Operand::Var(cond_var), // Use the bound var
                     then_branch: Box::new(then_expr),
                     else_branch: Box::new(else_expr),
                 }),
                 ty: final_hir_ty, // Type should be unified by type checker
                 span,
             };

             build_nested_lets(cond_bindings, tail_if_expr, span)
        }

        TypedExprKind::LogicalAnd { left, right } => {
            // Desugar `a && b` into `if a { b } else { false }`
            let mut cond_bindings = Vec::new();
            let cond_operand = lower_sub_expr_to_operand(left, ctx, defs, &mut cond_bindings);

            let then_expr = lower_expression(ctx, right, defs); // Evaluate right if left is true
            let else_expr = HirExpr { // Return false if left is false
                 kind: HirExprKind::Tail(HirTailExpr::Value(Operand::Const(HirLiteral::BoolLiteral(false)))),
                 ty: HirType::Primitive(PrimitiveType::Bool),
                 span: left.span, // Adjust span?
             };

             // --- Always bind condition result ---
             let cond_var = ctx.fresh_hir_var();
             let cond_hir_ty = lower_type(&left.ty, ctx); // Get type of 'a'
             cond_bindings.push((cond_var, cond_hir_ty, HirValue::Use(cond_operand)));
             // --- End Fix ---

             let tail_if_expr = HirExpr {
                 kind: HirExprKind::Tail(HirTailExpr::If {
                     condition: Operand::Var(cond_var), // Use bound var
                     then_branch: Box::new(then_expr),
                     else_branch: Box::new(else_expr),
                 }),
                 ty: final_hir_ty, // Should be Bool
                 span,
             };

             build_nested_lets(cond_bindings, tail_if_expr, span)
        }
         TypedExprKind::LogicalOr { left, right } => {
            // Desugar `a || b` into `if a { true } else { b }`
            let mut cond_bindings = Vec::new();
            let cond_operand = lower_sub_expr_to_operand(left, ctx, defs, &mut cond_bindings);

             let then_expr = HirExpr { // Return true if left is true
                 kind: HirExprKind::Tail(HirTailExpr::Value(Operand::Const(HirLiteral::BoolLiteral(true)))),
                 ty: HirType::Primitive(PrimitiveType::Bool),
                 span: left.span, // Adjust span?
             };
            let else_expr = lower_expression(ctx, right, defs); // Evaluate right if left is false

             // --- Always bind condition result ---
             let cond_var = ctx.fresh_hir_var();
             let cond_hir_ty = lower_type(&left.ty, ctx); // Get type of 'a'
             cond_bindings.push((cond_var, cond_hir_ty, HirValue::Use(cond_operand)));
             // --- End Fix ---

             let tail_if_expr = HirExpr {
                 kind: HirExprKind::Tail(HirTailExpr::If {
                     condition: Operand::Var(cond_var), // Use bound var
                     then_branch: Box::new(then_expr),
                     else_branch: Box::new(else_expr),
                 }),
                 ty: final_hir_ty, // Should be Bool
                 span,
             };

             build_nested_lets(cond_bindings, tail_if_expr, span)
        }

        TypedExprKind::Match { scrutinee, arms } => {
            // First, lower scrutinee and collect bindings
            let mut scrutinee_bindings = Vec::new();
            let scrutinee_operand = lower_sub_expr_to_operand(scrutinee, ctx, defs, &mut scrutinee_bindings);

            // Lower each match arm: pattern and body
            let mut hir_arms = Vec::new();
            let mut hir_otherwise: Option<Box<HirExpr>> = None;
            // let match_span = span; // Capture span for use inside loop - not used?

            let num_arms = arms.len();
            let mut last_arm_is_wildcard = false;

            // Check if the last arm is a catch-all wildcard or identifier binding
            if let Some(last_arm) = arms.last() {
                match last_arm.pattern.kind {
                    TypedPatternKind::Wildcard | TypedPatternKind::Identifier { .. } => {
                        last_arm_is_wildcard = true;
                    }
                    _ => {}
                }
            }

            // Iterate through arms, excluding the last one if it's a wildcard
            let arms_to_process = if last_arm_is_wildcard { &arms[..num_arms-1] } else { &arms[..] };

            for arm in arms_to_process {
                let arm_span = arm.pattern.span; // Span for bindings originating from this arm's pattern
                ctx.push_scope();
                // Lower the arm's pattern and body (existing logic)
                let (arm_hir_pattern, arm_hir_body) = match &arm.pattern.kind {
                    // --- Desugar Complex Patterns ---
                    TypedPatternKind::Tuple(elements) => {
                        let mut arm_specific_bindings = Vec::new();
                        for (i, element_pattern) in elements.iter().enumerate() {
                            // Project element
                            let proj_val = HirValue::Project {
                                base: scrutinee_operand.clone(),
                                projection: ProjectionKind::TupleIndex(i as u32),
                            };
                            let proj_var = ctx.fresh_hir_var();
                            let proj_var_ty = lower_type(&element_pattern.ty, ctx);
                            arm_specific_bindings.push((proj_var, proj_var_ty, proj_val));
                            // Handle bindings within the element pattern
                            let sub_bindings = lower_pattern_binding(ctx, element_pattern, Operand::Var(proj_var), defs);
                            arm_specific_bindings.extend(sub_bindings);
                        }
                        let original_body = lower_expression(ctx, &arm.body, defs);
                        let wrapped_body = build_nested_lets(arm_specific_bindings, original_body, arm_span);
                        (HirPattern::Wildcard, wrapped_body)
                    }
                    TypedPatternKind::Struct { struct_name, fields, .. } => {
                        let mut arm_specific_bindings = Vec::new();
                        let struct_def = ctx.definitions().structs.values().find(|s| s.name == *struct_name)
                            .unwrap_or_else(|| panic!("Struct '{}' not found for match pattern lowering", struct_name));
                        for field_pattern_info in fields {
                            let field_def = struct_def.fields.iter()
                                .find(|f| f.name == field_pattern_info.name)
                                .unwrap_or_else(|| panic!("Field '{}' not found in struct '{}' for match pattern lowering", field_pattern_info.name, struct_name));
                            let field_symbol = field_def.symbol;
                            let proj_val = HirValue::Project {
                                base: scrutinee_operand.clone(),
                                projection: ProjectionKind::Field(field_symbol),
                            };
                            let proj_var = ctx.fresh_hir_var();
                            let proj_var_ty = lower_type(&field_def.ty, ctx);
                            arm_specific_bindings.push((proj_var, proj_var_ty, proj_val));
                            // field_pattern_info.pattern is TypedPattern, not Option<TypedPattern>
                            // Remove the if let Some(...)
                            let sub_pattern = &field_pattern_info.pattern; // Get reference to the pattern
                            let sub_bindings = lower_pattern_binding(ctx, sub_pattern, Operand::Var(proj_var), defs);
                            arm_specific_bindings.extend(sub_bindings);
                        }
                        let original_body = lower_expression(ctx, &arm.body, defs);
                        let wrapped_body = build_nested_lets(arm_specific_bindings, original_body, arm_span);
                        (HirPattern::Wildcard, wrapped_body)
                    }
                    TypedPatternKind::Array(elements) => {
                        let mut arm_specific_bindings = Vec::new();
                        for (i, element_pattern) in elements.iter().enumerate() {
                            let index_operand = Operand::Const(HirLiteral::IntLiteral { value: i as i128, ty: PrimitiveType::U64}); // Assume u64 for array indices
                            let proj_val = HirValue::Project {
                                base: scrutinee_operand.clone(),
                                projection: ProjectionKind::ArrayIndex(index_operand),
                            };
                            let proj_var = ctx.fresh_hir_var();
                            let proj_var_ty = lower_type(&element_pattern.ty, ctx);
                            arm_specific_bindings.push((proj_var, proj_var_ty, proj_val));
                            let sub_bindings = lower_pattern_binding(ctx, element_pattern, Operand::Var(proj_var), defs);
                            arm_specific_bindings.extend(sub_bindings);
                        }
                        let original_body = lower_expression(ctx, &arm.body, defs);
                        let wrapped_body = build_nested_lets(arm_specific_bindings, original_body, arm_span);
                        (HirPattern::Wildcard, wrapped_body)
                    }
                    // --- Simple Patterns (handled by lower_pattern) ---
                    _ => {
                        let (simple_hir_pattern, pattern_bindings) = lower_pattern(ctx, &arm.pattern, defs);
                        for (symbol, hir_var, ty) in pattern_bindings {
                            ctx.add_binding_with_type(symbol, hir_var, ty);
                        }
                        let original_body = lower_expression(ctx, &arm.body, defs);
                        (simple_hir_pattern, original_body)
                    }
                };
                ctx.pop_scope();
                hir_arms.push((arm_hir_pattern, arm_hir_body));
            }

            // Process the last arm separately if it was a wildcard
            if last_arm_is_wildcard {
                if let Some(last_arm) = arms.last() {
                    ctx.push_scope(); // Need scope for potential bindings in the wildcard arm itself (e.g., `x => ...`)
                    
                    // Handle potential binding in the wildcard/identifier arm (e.g., `x => ...`)
                    // We need to add the binding to the context *before* lowering the body.
                    match &last_arm.pattern.kind {
                        TypedPatternKind::Identifier { .. } => {
                            // Use lower_pattern to get the binding info (Symbol, HirVar, Ty)
                            let (_, pattern_bindings) = lower_pattern(ctx, &last_arm.pattern, defs);
                            if let Some((symbol, hir_var, ty)) = pattern_bindings.into_iter().next() {
                                // Add the binding for the identifier `x` to the context
                                ctx.add_binding_with_type(symbol, hir_var, ty);
                            } else {
                                panic!("Internal Error: lower_pattern for Identifier did not return binding info.");
                            }
                        }
                        TypedPatternKind::Wildcard => {
                            // No binding needed for `_`
                        }
                        _ => {
                             panic!("Internal Error: last_arm_is_wildcard check mismatch with actual pattern kind: {:?}", last_arm.pattern.kind);
                        }
                    }
                    
                    // Lower the body of the wildcard arm (bindings are now in context)
                    let otherwise_body = lower_expression(ctx, &last_arm.body, defs);
                    hir_otherwise = Some(Box::new(otherwise_body));
                    ctx.pop_scope();
                }
            }

            // --- Fix: Bind scrutinee operand if it's not already a simple Var --- 
            let final_scrutinee_operand;
            if !matches!(scrutinee_operand, Operand::Var(_)) {
                 let scrutinee_var = ctx.fresh_hir_var();
                 let scrutinee_ty = lower_type(&scrutinee.ty, ctx);
                 scrutinee_bindings.push((scrutinee_var, scrutinee_ty, HirValue::Use(scrutinee_operand)));
                 final_scrutinee_operand = Operand::Var(scrutinee_var);
            } else {
                 final_scrutinee_operand = scrutinee_operand;
            }
            // --- End Fix ---

            // Create the Match expression
            let match_expr = HirExpr {
                kind: HirExprKind::Tail(HirTailExpr::Match {
                    scrutinee: final_scrutinee_operand,
                    arms: hir_arms,
                    otherwise: hir_otherwise,
                }),
                ty: final_hir_ty,
                span,
            };

            // Wrap with any bindings needed for the scrutinee
            build_nested_lets(scrutinee_bindings, match_expr, span)
        }

        // Handle Block expressions - *** REVISED LOGIC ***
        TypedExprKind::Block(exprs) => {
            if exprs.is_empty() {
                // Empty block returns Unit
                return HirExpr {
                    kind: HirExprKind::Tail(HirTailExpr::Value(Operand::Const(HirLiteral::Unit))),
                    ty: HirType::Tuple(vec![]),
                    span,
                };
            }

            // Create a new scope for the block
            ctx.push_scope();

            let mut all_bindings = Vec::new();
            let num_stmts = exprs.len() - 1;

            // Process statements sequentially (except the last expression)
            for stmt_expr in exprs.iter().take(num_stmts) {
                let stmt_span = stmt_expr.span;
                match &stmt_expr.kind {
                    TypedExprKind::Let { pattern, value } => {
                        let mut value_bindings = Vec::new();
                        let value_operand = lower_sub_expr_to_operand(value, ctx, defs, &mut value_bindings);
                        let pattern_bindings = lower_pattern_binding(ctx, pattern, value_operand, defs);

                        // Add bindings to the list for this block
                        all_bindings.extend(value_bindings);
                        all_bindings.extend(pattern_bindings);
                    }
                    _ => {
                        // Lower other statement types (e.g., calls for side effects)
                        let stmt_as_hir_expr = lower_expression(ctx, stmt_expr, defs);
                        let (stmt_bindings, stmt_tail) = flatten_hir_expr(stmt_as_hir_expr);
                        all_bindings.extend(stmt_bindings); // Add any bindings from the statement

                        // Ensure the statement's result (if not Unit) is bound to a dummy var
                        if let HirTailExpr::Value(operand) = stmt_tail {
                            let stmt_type = lower_type(&stmt_expr.ty, ctx);
                            if !matches!(stmt_type, HirType::Tuple(ref v) if v.is_empty()) {
                                let dummy_var = ctx.fresh_hir_var();
                                all_bindings.push((dummy_var, stmt_type, HirValue::Use(operand)));
                            }
                        } else if !matches!(stmt_tail, HirTailExpr::Never) {
                            // This should not happen if the type system enforces statements have types
                            // or if non-Let statements are restricted (e.g., only calls).
                            panic!("Lowering Error: Non-Let, non-Call statement found mid-block without returning a value? Span: {:?}", stmt_span);
                        }
                        // If stmt_tail is Never, we don't add more bindings, but the `Never` effect propagates.
                    }
                }
            }

            // Lower the final expression of the block
            let final_expr = lower_expression(ctx, exprs.last().unwrap(), defs);

            // Pop the scope for the block
            ctx.pop_scope();

            // Wrap the final expression with all the bindings collected from the statements
            build_nested_lets(all_bindings, final_expr, span)
        }

        TypedExprKind::Error => {
            // Type errors should be caught before HIR lowering.
            unreachable!("Error type encountered during HIR lowering at span {:?}", span);
        }

        // --- Expressions producing a value (handled by helper) ---
        _ => {
            // This path handles: Literal, Variable, Paren, Tuple, Array, Struct,
            // VariantConstructor, Field, Call.
            // Lambda is handled directly in lower_to_value_and_bindings.
            let (hir_value, mut bindings) = lower_to_value_and_bindings(ctx, expr, defs);

            // Determine the final expression: either return the operand directly
            // or bind the computed value and return the variable.
            let final_tail_expr;
            match hir_value {
                HirValue::Use(op) => {
                    // Value was already simple, return it directly.
                    final_tail_expr = HirExpr {
                        kind: HirExprKind::Tail(HirTailExpr::Value(op)),
                        ty: final_hir_ty.clone(),
                        span,
                    };
                }
                _ => {
                    // The value was complex (e.g., Aggregate, Call, Closure), bind it.
                    let result_var = ctx.fresh_hir_var();
                    bindings.push((result_var, final_hir_ty.clone(), hir_value));
                    final_tail_expr = HirExpr {
                        kind: HirExprKind::Tail(HirTailExpr::Value(Operand::Var(result_var))),
                        ty: final_hir_ty.clone(),
                        span,
                    };
                }
            }

            // Construct the final nested Let expression from all bindings.
            build_nested_lets(bindings, final_tail_expr, span)
        }
    }
}

/// Helper function to construct nested Let expressions.
fn build_nested_lets(bindings: Vec<BindingData>, final_expr: HirExpr, _span: SourceSpan) -> HirExpr { // Use BindingData, span ignored for now
    let mut current_expr = final_expr;
    for (var, var_ty, value) in bindings.into_iter().rev() {
        // Use the span of the expression being wrapped for the outer Let span
        let outer_span = current_expr.span;
        let outer_ty = current_expr.ty.clone(); // Type propagates from inner expr
        current_expr = HirExpr {
             kind: HirExprKind::Let {
                 var,
                 var_ty, // Type of the bound variable itself
                 value: Box::new(value),
                 rest: Box::new(current_expr),
             },
             ty: outer_ty, // Type of the overall expression
             span: outer_span, // Use outer span for nested Lets
         };
    }
    current_expr
}

/// Helper to decompose an HirExpr into bindings and the final tail expression.
/// Note: This consumes the expression.
fn flatten_hir_expr(expr: HirExpr) -> (Vec<BindingData>, HirTailExpr) {
    let mut bindings = Vec::new();
    let mut current_expr = expr;

    loop {
        match current_expr.kind {
            HirExprKind::Let { var, var_ty, value, rest } => {
                bindings.push((var, var_ty, *value));
                current_expr = *rest;
            }
            HirExprKind::Tail(tail_expr) => {
                // Reverse bindings to maintain original order for build_nested_lets
                bindings.reverse();
                return (bindings, tail_expr);
            }
        }
    }
}

/// Information about a captured variable.
#[derive(Debug, Clone)]
struct CaptureInfo {
    symbol: TypeSymbol, // Symbol from the typed AST
    ty: Ty,             // Type of the captured variable
    span: SourceSpan,   // Span where capture occurs (first usage)
}

/// Analyzes an expression to find free variables (symbols defined outside the expression)
fn analyze_captures(ctx: &LoweringContext, body: &TypedExpr) -> Vec<(TypeSymbol, Ty)> {
    let mut free_vars = HashSet::new();
    let mut defined_vars_stack: Vec<HashSet<TypeSymbol>> = vec![HashSet::new()]; // Track defined vars per scope within the lambda

    find_free_variables_recursive(ctx, body, &mut defined_vars_stack, &mut free_vars);

    // --- DEBUG --- 
    println!("[analyze_captures] Found potential free vars: {:?}", free_vars);
    // ------------- 

    // Convert the set of free variable symbols and their types into a Vec
    let captures: Vec<(TypeSymbol, Ty)> = free_vars
        .into_iter()
        .filter_map(|symbol| {
            // Get the HirVar and original Ty from the outer context
            let hir_var_opt = ctx.get_hir_var(symbol);
            let ty_opt = ctx.get_type_for_symbol(symbol);

            match (hir_var_opt, ty_opt) {
                (Some(_), Some(ty)) => {
                    // Both HirVar and Ty found, this is a valid capture
                    Some((symbol, ty))
                }
                (Some(_), None) => {
                    // HirVar found but Ty missing - indicates an internal inconsistency
                    // Should not happen if add_binding_with_type is used correctly everywhere.
                    panic!(
                        "Lowering Error: Found HirVar but no Ty for captured symbol {:?}. Check binding registration.",
                        symbol
                    );
                    // None // Or return None to skip if panic is too harsh
                }
                (None, Some(_)) => {
                    // Ty found but HirVar missing - indicates an internal inconsistency
                    panic!(
                        "Lowering Error: Found Ty but no HirVar for captured symbol {:?}. Check binding registration.",
                        symbol
                    );
                    // None
                }
                (None, None) => {
                    // Neither found - this symbol was likely identified as potentially free
                    // but wasn't actually defined in the outer context accessible to the lambda.
                    // This can happen if `find_free_variables_recursive` adds a symbol
                    // that's truly undefined (should be caught by type checker).
                    // We filter these out silently.
                    None
                }
            }
        })
        .collect();
    
    // --- DEBUG --- 
    println!("[analyze_captures] Filtered captures: {:?}", captures.iter().map(|(s,_)|s).collect::<Vec<_>>());
    // ------------- 

    captures
}

/// Recursive helper to find free variables in an expression relative to the current definition context.
fn find_free_variables_recursive(
    ctx: &LoweringContext, // Read-only access to outer context for checking if var is defined *outside*
    expr: &TypedExpr,
    defined_vars_stack: &mut Vec<HashSet<TypeSymbol>>, // Variables defined *within* the lambda
    free_vars: &mut HashSet<TypeSymbol>, // Accumulator for free variables
) {
    // Get current scope's defined variables
    let current_scope_defined = defined_vars_stack.last().expect("Scope stack should not be empty");

    match &expr.kind {
        TypedExprKind::Variable { symbol, .. } => {
            // Check if the variable is defined in the current or any parent scope *within* the lambda
            let is_defined_locally = defined_vars_stack.iter().any(|scope| scope.contains(symbol));
            // Check if defined in the outer context (as a var or a global func)
            let is_defined_externally = ctx.get_hir_var(*symbol).is_some() || 
                                        ctx.definitions().functions.contains_key(symbol);

            // Fix: A variable is free (captured) if NOT defined locally BUT IS defined externally.
            if !is_defined_locally && is_defined_externally {
                // If not defined locally, but is defined in the outer context, it's a captured free variable.
                free_vars.insert(*symbol);
            }
        }
        // Update match to cover specific literal kinds
        TypedExprKind::IntLiteral { .. } | 
        TypedExprKind::FloatLiteral { .. } | 
        TypedExprKind::StringLiteral(_) | 
        TypedExprKind::CharLiteral(_) | 
        TypedExprKind::BoolLiteral(_) => { /* No variables */ }
        TypedExprKind::Paren(inner) => {
            find_free_variables_recursive(ctx, inner, defined_vars_stack, free_vars);
        }
        TypedExprKind::Tuple(elements) | TypedExprKind::Array(elements) => {
            for elem in elements {
                find_free_variables_recursive(ctx, elem, defined_vars_stack, free_vars);
            }
        }
        TypedExprKind::Struct { fields, base, .. } => {
            if let Some(base_expr) = base {
                find_free_variables_recursive(ctx, base_expr, defined_vars_stack, free_vars);
            }
            for (_, field_expr) in fields {
                find_free_variables_recursive(ctx, field_expr, defined_vars_stack, free_vars);
            }
        }
        TypedExprKind::VariantConstructor { args, .. } => {
            for arg in args {
                find_free_variables_recursive(ctx, &arg.value, defined_vars_stack, free_vars);
            }
        }
        TypedExprKind::Field { object, .. } => {
            find_free_variables_recursive(ctx, object, defined_vars_stack, free_vars);
        }
        TypedExprKind::Call { func_expr, args, .. } => {
            find_free_variables_recursive(ctx, func_expr, defined_vars_stack, free_vars);
            for arg in args {
                find_free_variables_recursive(ctx, &arg.value, defined_vars_stack, free_vars);
            }
        }
        TypedExprKind::Lambda { params, body } => {
            // --- Lambda Scope Handling ---
            // 1. Create a new scope for the lambda body, adding parameters.
            let mut lambda_scope = HashSet::new();
            for param in params {
                lambda_scope.insert(param.symbol);
            }
            defined_vars_stack.push(lambda_scope);

            // 2. Recursively analyze the lambda body.
            //    Free variables found within the body that are defined *outside* this lambda
            //    are the captures we are interested in for the *outer* context analysis.
            find_free_variables_recursive(ctx, body, defined_vars_stack, free_vars);

            // 3. Pop the lambda's scope.
            defined_vars_stack.pop();
            // --- End Lambda Scope Handling ---
        }
        TypedExprKind::Let { pattern, value } => {
            // Analyze value first (bindings not in scope yet)
            find_free_variables_recursive(ctx, value, defined_vars_stack, free_vars);
            // Add pattern bindings to a new scope
            let mut let_scope = defined_vars_stack.last().cloned().unwrap_or_default();
            collect_pattern_bindings(pattern, &mut let_scope);
            defined_vars_stack.push(let_scope);
            // Pop scope immediately since there's no 'rest' field
            defined_vars_stack.pop();
        }
        TypedExprKind::If { condition, then_branch, else_branch } => {
            find_free_variables_recursive(ctx, condition, defined_vars_stack, free_vars);
            find_free_variables_recursive(ctx, then_branch, defined_vars_stack, free_vars);
            if let Some(else_b) = else_branch {
                find_free_variables_recursive(ctx, else_b, defined_vars_stack, free_vars);
            }
        }
        TypedExprKind::Match { scrutinee, arms } => {
            find_free_variables_recursive(ctx, scrutinee, defined_vars_stack, free_vars);
            for arm in arms {
                // Create a new scope for each arm, including bindings from the pattern
                let mut arm_scope = defined_vars_stack.last().cloned().unwrap_or_default();
                collect_pattern_bindings(&arm.pattern, &mut arm_scope);
                defined_vars_stack.push(arm_scope);

                // Analyze the arm body within the new scope
                find_free_variables_recursive(ctx, &arm.body, defined_vars_stack, free_vars);

                // Pop the arm's scope
                defined_vars_stack.pop();
            }
        }
        TypedExprKind::Block(items) => {
            // Create a new scope for the block
            defined_vars_stack.push(HashSet::new());
            for item in items {
                find_free_variables_recursive(ctx, item, defined_vars_stack, free_vars);
                 // If item is a let binding, add its pattern bindings to the current scope
                 if let TypedExprKind::Let { pattern, .. } = &item.kind {
                    let current_scope = defined_vars_stack.last_mut().unwrap();
                     collect_pattern_bindings(pattern, current_scope);
                 }
            }
            // Pop the block's scope
            defined_vars_stack.pop();
        }
        TypedExprKind::Error => { /* Ignore errors */ }
        TypedExprKind::Map(entries) => {
            for (key, value) in entries {
                find_free_variables_recursive(ctx, key, defined_vars_stack, free_vars);
                find_free_variables_recursive(ctx, value, defined_vars_stack, free_vars);
            }
        }
        TypedExprKind::HashSet(elements) => {
            for elem in elements {
                find_free_variables_recursive(ctx, elem, defined_vars_stack, free_vars);
            }
        }
        TypedExprKind::LogicalAnd { left, right } => {
            find_free_variables_recursive(ctx, left, defined_vars_stack, free_vars);
            find_free_variables_recursive(ctx, right, defined_vars_stack, free_vars);
        }
        TypedExprKind::LogicalOr { left, right } => {
            find_free_variables_recursive(ctx, left, defined_vars_stack, free_vars);
            find_free_variables_recursive(ctx, right, defined_vars_stack, free_vars);
        }
        TypedExprKind::TupleField { tuple, index } => {
            find_free_variables_recursive(ctx, tuple, defined_vars_stack, free_vars);
        }
    }
}

/// Helper to recursively collect variable symbols defined by a pattern.
fn collect_pattern_bindings(pattern: &TypedPattern, scope: &mut HashSet<TypeSymbol>) {
    match &pattern.kind {
        TypedPatternKind::Identifier { symbol, name } if name != "_" => {
            scope.insert(*symbol);
        }
        TypedPatternKind::Tuple(elements) | TypedPatternKind::Array(elements) => {
            for elem in elements {
                collect_pattern_bindings(elem, scope);
            }
        }
        TypedPatternKind::Struct { fields, .. } => {
            for field in fields {
                // field.pattern is TypedPattern, not Option
                let pat = &field.pattern;
                collect_pattern_bindings(pat, scope);
            }
        }
        TypedPatternKind::Constructor { args, .. } => {
            // args is Vec<TypedPatternArgument>, iterate through it
            for arg in args {
                match arg {
                    TypedPatternArgument::Positional(pat) => collect_pattern_bindings(pat, scope),
                    TypedPatternArgument::Named(field_pat) => collect_pattern_bindings(&field_pat.pattern, scope),
                    TypedPatternArgument::Rest(_) => {} // Ignore span
                }
            }
        }
        TypedPatternKind::Or(p1, p2) => {
            // Or patterns require careful handling - bindings might not be consistent.
            // Type checker should ideally prevent invalid Or patterns.
            // Assume bindings are consistent for now.
             let mut scope1 = HashSet::new();
             let mut scope2 = HashSet::new();
             collect_pattern_bindings(p1, &mut scope1);
             collect_pattern_bindings(p2, &mut scope2);
             // We should only add bindings present in *both* branches if required for soundness,
             // but let's assume the type checker ensured consistency and add all.
             scope.extend(scope1);
             scope.extend(scope2);
        }
        TypedPatternKind::Literal(_) | TypedPatternKind::Wildcard | TypedPatternKind::Rest | TypedPatternKind::Identifier { .. } => {
            // No nested bindings
        }
    }
}

/// Generates an HirFunction for a lambda's body.
fn generate_lambda_function<'def>(
    outer_ctx: &mut LoweringContext<'def>, // Use outer context for lowering body
    outer_defs: &'def TypedDefinitions,
    lambda_fn_symbol: Symbol, // Use TypeSymbol alias
    lambda_span: SourceSpan,
    params: &[(TypeSymbol, Ty)], // Original lambda params (Symbol + Type)
    captures: &[(TypeSymbol, Ty)], // Captured free variables (Symbol + Type)
    body: &'def TypedExpr, // Ensure body has 'def lifetime
) -> HirFunction {

    // Create a *new*, separate lowering context for the lambda body
    // to ensure variable mapping (symbol -> HirVar) is independent.
    let mut lambda_ctx = LoweringContext::new(outer_ctx.definitions()); // Share defs, but new var maps

    // --- Prepare Parameters for HIR function --- 
    let mut hir_params: Vec<(HirVar, HirType)> = Vec::new();
    // No need for lambda_body_scope HashMap, add_binding_with_type handles it.

    // 1. Add captured variables as the first parameters
    for (capture_symbol, capture_ty) in captures {
        let hir_var = lambda_ctx.fresh_hir_var();
        let hir_type = lower_type(capture_ty, &mut lambda_ctx); // Lower type in lambda's context
        hir_params.push((hir_var, hir_type));
        // Map the original capture symbol to the new HirVar AND store its Ty
        // *within the lambda's context*
        lambda_ctx.add_binding_with_type(*capture_symbol, hir_var, capture_ty.clone());
    }

    // 2. Add original lambda parameters
    for (param_symbol, param_ty) in params {
        let hir_var = lambda_ctx.fresh_hir_var();
        let hir_type = lower_type(param_ty, &mut lambda_ctx);
        hir_params.push((hir_var, hir_type));
         // Map the original param symbol to the new HirVar AND store its Ty
         // *within the lambda's context*
         lambda_ctx.add_binding_with_type(*param_symbol, hir_var, param_ty.clone());
    }

    // --- Lower Body ---
    // The body is lowered using the lambda's context, where captures and params are pre-defined.
    let hir_body = lower_expression(&mut lambda_ctx, body, outer_defs); // Use outer_defs

    // --- Create Signature ---
    let return_ty = hir_body.ty.clone(); // Return type is inferred from lowered body
    let signature = HirFunctionSignature {
        params: hir_params, // Use the HIR params generated above
        return_type: return_ty,
        is_effectful: analyze_hir_expr_for_effects(&hir_body),
    };

    // --- Create Function ---
    let lambda_fn = HirFunction {
        symbol: lambda_fn_symbol,
        name: format!("lambda_{}", lambda_fn_symbol.id()), // Generate unique name
        signature,
        body: Some(hir_body),
        span: lambda_span, // Use span of the original lambda expression
    };

    // Transfer any nested lambda functions generated during body lowering
    // from the lambda_ctx to the outer_ctx.
    outer_ctx.generated_lambda_functions.extend(lambda_ctx.generated_lambda_functions);

    lambda_fn
}

/// Analyzes an HIR expression recursively to determine if it might have side effects.
/// Currently, it flags any function call as potentially effectful.
/// TODO: Refine this to check if the called function itself is known to be effectful.
/// TODO: Refine this. Possibilities:
/// TODO: 1. Pass function signatures/definitions during analysis to check `is_effectful` flag for `Operand::Global` calls.
/// TODO: 2. Implement a separate post-lowering pass to determine and propagate effect information.
/// TODO: 3. Assume closures (`Operand::Var` as function) are potentially effectful unless proven otherwise.
fn analyze_hir_expr_for_effects(expr: &HirExpr) -> bool {
    match &expr.kind {
        HirExprKind::Let { value, rest, .. } => {
            // Check the bound value and the rest of the expression
            analyze_hir_value_for_effects(value) || analyze_hir_expr_for_effects(rest)
        }
        HirExprKind::Tail(tail_expr) => analyze_hir_tail_expr_for_effects(tail_expr),
    }
}

/// Helper to analyze HirValue for effects.
fn analyze_hir_value_for_effects(value: &HirValue) -> bool {
    match value {
        HirValue::Call { .. } => true, // Any call is potentially effectful
        HirValue::Aggregate { fields, .. } => fields.iter().any(analyze_operand_for_effects),
        HirValue::Project { base, .. } => analyze_operand_for_effects(base),
        HirValue::Closure { captures, .. } => captures.iter().any(analyze_operand_for_effects),
        HirValue::Use(operand) => analyze_operand_for_effects(operand),
    }
}

/// Helper to analyze HirTailExpr for effects.
fn analyze_hir_tail_expr_for_effects(tail_expr: &HirTailExpr) -> bool {
    match tail_expr {
        HirTailExpr::Value(operand) => analyze_operand_for_effects(operand),
        HirTailExpr::Match { scrutinee, arms, otherwise } => {
            analyze_operand_for_effects(scrutinee)
                || arms.iter().any(|(_, body)| analyze_hir_expr_for_effects(body))
                || otherwise.as_ref().map_or(false, |body| analyze_hir_expr_for_effects(body))
        }
        HirTailExpr::If { condition, then_branch, else_branch } => {
            analyze_operand_for_effects(condition)
                || analyze_hir_expr_for_effects(then_branch)
                || analyze_hir_expr_for_effects(else_branch)
        }
        HirTailExpr::Never => false,
    }
}

/// Helper to analyze Operand for effects (currently, only checks contained constants/vars - trivially false).
fn analyze_operand_for_effects(_operand: &Operand) -> bool {
    // match operand {
    //     Operand::Const(_) | Operand::Var(_) | Operand::Global(_) => false,
    // }
    false // Simplified
}

#[cfg(test)]
mod tests {
    use super::{lower_expression, lower_sub_expr_to_operand, lower_to_value_and_bindings};
    use crate::hir::{HirExpr, HirExprKind, HirValue, HirTailExpr, Operand, HirLiteral, HirType, HirVar, AggregateKind, ProjectionKind, PrimitiveType as HirPrimitive};
    use crate::lower::{LoweringContext, types::lower_type};
    use parallax_resolve::types::{Symbol, PrimitiveType as ResolvePrimitive};
    use parallax_syntax::ast::common::Literal as AstLiteral;
    use parallax_types::types::{Ty, TyKind, PrimitiveType as TypesPrimitive, TypedExpr, TypedExprKind, TypedDefinitions, TypedArgument};
    use miette::SourceSpan;
    use std::collections::HashMap;
    use std::sync::Arc;

    // --- Test Helpers ---
    fn dummy_span() -> SourceSpan {
        SourceSpan::from((0, 0))
    }

    fn dummy_ty(kind: TyKind) -> Ty {
        Ty { kind, span: Some(dummy_span()) }
    }

    fn dummy_expr(kind: TypedExprKind, ty_kind: TyKind) -> TypedExpr {
        TypedExpr {
            kind,
            ty: dummy_ty(ty_kind),
            span: dummy_span(),
        }
    }

    fn create_test_context() -> LoweringContext<'static> {
        let defs = Box::leak(Box::new(TypedDefinitions::default()));
        LoweringContext::new(defs)
    }

    // --- lower_sub_expr_to_operand Tests ---

    #[test]
    fn test_sub_expr_to_operand_literal() {
        let mut ctx = create_test_context();
        let defs = TypedDefinitions::default();
        let mut bindings = Vec::new();
        let expr = dummy_expr(TypedExprKind::IntLiteral { value: 123, suffix: None }, TyKind::Primitive(TypesPrimitive::I64));

        let operand = lower_sub_expr_to_operand(&expr, &mut ctx, &defs, &mut bindings);

        assert_eq!(operand, Operand::Const(HirLiteral::IntLiteral { value: 123, ty: HirPrimitive::I64 }));
        assert!(bindings.is_empty());
    }

    #[test]
    fn test_sub_expr_to_operand_variable() {
        let mut ctx = create_test_context();
        let var_symbol = Symbol::new(5);
        let hir_var = ctx.get_or_create_hir_var(var_symbol);
        ctx.add_binding_with_type(var_symbol, hir_var, dummy_ty(TyKind::Primitive(TypesPrimitive::Bool)));

        let defs = TypedDefinitions::default();
        let mut bindings = Vec::new();
        let expr = dummy_expr(
            TypedExprKind::Variable { symbol: var_symbol, name: "v".to_string() },
            TyKind::Primitive(TypesPrimitive::Bool)
        );

        let operand = lower_sub_expr_to_operand(&expr, &mut ctx, &defs, &mut bindings);

        assert_eq!(operand, Operand::Var(hir_var));
        assert!(bindings.is_empty());
    }

    #[test]
    fn test_sub_expr_to_operand_complex() {
        // Test that a complex expression generates bindings and returns a Var
        let mut ctx = create_test_context();
        let defs = TypedDefinitions::default();
        let mut bindings = Vec::new();
        let expr = dummy_expr(
            TypedExprKind::Tuple(vec![ // A tuple is complex, needs binding
                 dummy_expr(TypedExprKind::IntLiteral { value: 1, suffix: None }, TyKind::Primitive(TypesPrimitive::I32)),
                 dummy_expr(TypedExprKind::BoolLiteral(true), TyKind::Primitive(TypesPrimitive::Bool)),
            ]),
            TyKind::Tuple(vec![dummy_ty(TyKind::Primitive(TypesPrimitive::I32)), dummy_ty(TyKind::Primitive(TypesPrimitive::Bool))])
        );

        let operand = lower_sub_expr_to_operand(&expr, &mut ctx, &defs, &mut bindings);

        assert_eq!(bindings.len(), 1); // Should create one binding for the tuple value
        let (bound_var, bound_ty, bound_value) = &bindings[0];
        // Check bound type and value
        assert_eq!(bound_ty, &HirType::Tuple(vec![HirType::Primitive(HirPrimitive::I32), HirType::Primitive(HirPrimitive::Bool)]));
        match bound_value {
            HirValue::Aggregate { kind: AggregateKind::Tuple, fields } => {
                assert_eq!(fields.len(), 2);
                assert_eq!(fields[0], Operand::Const(HirLiteral::IntLiteral { value: 1, ty: HirPrimitive::I32 }));
                assert_eq!(fields[1], Operand::Const(HirLiteral::BoolLiteral(true)));
            }
            _ => panic!("Expected Aggregate::Tuple, found {:?}", bound_value)
        }

        // Operand should be the variable bound to the tuple
        assert_eq!(operand, Operand::Var(*bound_var));
        // Check the HirVar ID. The first fresh_hir_var call happens inside lower_sub_expr_to_operand for the binding
        assert_eq!(bound_var, &HirVar(0));
    }

     // --- lower_to_value_and_bindings Tests ---

     #[test]
     fn test_lower_value_literal() {
        let mut ctx = create_test_context();
        let defs = TypedDefinitions::default();
        let expr = dummy_expr(
            TypedExprKind::BoolLiteral(false),
            TyKind::Primitive(TypesPrimitive::Bool)
        );
        let (value, bindings) = lower_to_value_and_bindings(&mut ctx, &expr, &defs);

        assert_eq!(value, HirValue::Use(Operand::Const(HirLiteral::BoolLiteral(false))));
        assert!(bindings.is_empty());
     }

    #[test]
    fn test_lower_value_aggregate_tuple() {
        let mut ctx = create_test_context();
        let defs = TypedDefinitions::default();
        let lit1 = dummy_expr(TypedExprKind::IntLiteral { value: 1, suffix: None }, TyKind::Primitive(TypesPrimitive::I32));
        let lit2 = dummy_expr(TypedExprKind::BoolLiteral(true), TyKind::Primitive(TypesPrimitive::Bool));
        let expr = dummy_expr(
            TypedExprKind::Tuple(vec![lit1, lit2]),
            TyKind::Tuple(vec![dummy_ty(TyKind::Primitive(TypesPrimitive::I32)), dummy_ty(TyKind::Primitive(TypesPrimitive::Bool))])
        );

        let (value, bindings) = lower_to_value_and_bindings(&mut ctx, &expr, &defs);

        assert!(bindings.is_empty()); // Literals don't create bindings here
        match value {
             HirValue::Aggregate { kind: AggregateKind::Tuple, fields } => {
                 assert_eq!(fields.len(), 2);
                 assert_eq!(fields[0], Operand::Const(HirLiteral::IntLiteral { value: 1, ty: HirPrimitive::I32 }));
                 assert_eq!(fields[1], Operand::Const(HirLiteral::BoolLiteral(true)));
             }
             _ => panic!("Expected Aggregate::Tuple, found {:?}", value)
        }
    }

    #[test]
    fn test_lower_value_aggregate_with_bindings() {
        // Tuple where one element is complex and needs binding
        let mut ctx = create_test_context();
        let defs = TypedDefinitions::default();
        let complex_elem = dummy_expr( // Tuple expr
            TypedExprKind::Tuple(vec![
                 dummy_expr(TypedExprKind::IntLiteral { value: 5, suffix: None }, TyKind::Primitive(TypesPrimitive::I32))
            ]),
            TyKind::Tuple(vec![dummy_ty(TyKind::Primitive(TypesPrimitive::I32))])
        );
        let simple_elem = dummy_expr(TypedExprKind::BoolLiteral(false), TyKind::Primitive(TypesPrimitive::Bool));

        let expr = dummy_expr(
            TypedExprKind::Tuple(vec![complex_elem, simple_elem]),
            TyKind::Tuple(vec![
                dummy_ty(TyKind::Tuple(vec![dummy_ty(TyKind::Primitive(TypesPrimitive::I32))])),
                dummy_ty(TyKind::Primitive(TypesPrimitive::Bool))
            ])
        );

        let (value, bindings) = lower_to_value_and_bindings(&mut ctx, &expr, &defs);

        // Expect one binding for the inner complex_elem tuple
        assert_eq!(bindings.len(), 1);
        let (bound_var, _, bound_value) = &bindings[0];
        assert_eq!(bound_var, &HirVar(0)); // First binding gets ID 0
        match bound_value {
            HirValue::Aggregate { kind: AggregateKind::Tuple, fields } if fields.len() == 1 => {
                assert_eq!(fields[0], Operand::Const(HirLiteral::IntLiteral { value: 5, ty: HirPrimitive::I32 }));
            }
            _ => panic!("Expected inner binding for tuple, found {:?}", bound_value)
        }

        // The final value should be an aggregate using the bound var and the literal
        match value {
             HirValue::Aggregate { kind: AggregateKind::Tuple, fields } => {
                 assert_eq!(fields.len(), 2);
                 assert_eq!(fields[0], Operand::Var(*bound_var)); // Uses the bound variable (HirVar(0))
                 assert_eq!(fields[1], Operand::Const(HirLiteral::BoolLiteral(false)));
             }
             _ => panic!("Expected outer Aggregate::Tuple, found {:?}", value)
        }
    }

     // --- lower_expression Tests ---
     // TODO: Add tests for lower_expression (handling Let, If, Match, Block etc.)
}

