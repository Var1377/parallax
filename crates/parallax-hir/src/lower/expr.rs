// parallax-hir/src/lower/expr.rs
// Lowers Typed AST expressions to ANF HIR expressions.

use super::*; // Import items from parent `mod.rs` (includes context, hir types, etc.)
use parallax_types::types::{TypedExpr, TypedExprKind, TypedDefinitions, TypedParameter, Ty, TyKind, PrimitiveType as ParallaxPrimitiveType, TypedArgument, TypedMatchArm, TypedPattern, TypedPatternKind, TypedVariant, TypedField}; // Added missing TypedPattern etc
use parallax_resolve::types::Symbol; // Use the public Symbol from resolve
use crate::hir::{HirExpr, HirExprKind, HirValue, HirTailExpr, Operand, HirType, HirFunction, HirFunctionSignature, HirVar, AggregateKind, HirLiteral, ProjectionKind, HirPattern, ResolvePrimitiveType}; // Added ResolvePrimitiveType
use std::mem;
use std::collections::{HashMap, HashSet};
use super::pattern::{lower_pattern_binding, lower_pattern};
use parallax_syntax::ast::common::Literal as AstLiteral; // Add import

// Type alias for binding data
type BindingData = (HirVar, HirType, HirValue);

/// Helper to lower a sub-expression to an operand, returning the operand
/// and the sequence of bindings required to compute it.
///
/// - `expr`: The sub-expression to lower.
/// - `ctx`: Lowering context.
/// - `defs`: Typed definitions.
/// - `bindings`: A mutable vector to accumulate the necessary let-bindings.
///
/// Returns the `Operand` representing the result of `expr`.
fn lower_sub_expr_to_operand<'def>(
    expr: &'def TypedExpr,
    ctx: &mut LoweringContext<'def>,
    defs: &'def TypedDefinitions,
    bindings: &mut Vec<BindingData> // Use BindingData type alias
) -> Operand {
    match &expr.kind {
        TypedExprKind::Literal(lit) => {
            Operand::Const(lower_literal(lit))
        }
        TypedExprKind::Variable { symbol, name: _ } => {
            if defs.functions.contains_key(symbol) {
                Operand::Global(*symbol)
            } else if let Some(var) = ctx.get_hir_var(*symbol) { // Use existing var if found
                 Operand::Var(var)
             } else {
                 // This case should ideally not be hit often if variables are declared
                 // before use, but handle it defensively by creating the var.
                 // Consider if a panic or error is more appropriate based on invariants.
                 Operand::Var(ctx.get_or_create_hir_var(*symbol))
             }
        }
        TypedExprKind::Paren(inner_expr) => {
            // Recurse
            lower_sub_expr_to_operand(inner_expr, ctx, defs, bindings)
        }
        // Complex cases: lower fully, bind result, return var
        _ => {
             // --- Final Approach: Use a helper that *returns* the value and bindings ---
            let (hir_value, new_bindings) = lower_to_value_and_bindings(ctx, expr, defs);

            // Add bindings generated by the sub-expression
            bindings.extend(new_bindings);

            // We only bind if the value isn't already a simple operand
            match hir_value {
                HirValue::Use(op) => op, // Already simple, use directly
                _ => { // Otherwise, create a binding for the computed value
                    let temp_var = ctx.fresh_hir_var();
                    let temp_var_ty = lower_type(&expr.ty, ctx);
                     // Push tuple instead of HirExprKind::Let
                     bindings.push((temp_var, temp_var_ty, hir_value));
                    Operand::Var(temp_var)
                }
            }
        }
    }
}

/// Lowers an expression to a HirValue, returning the value and any
/// bindings needed to compute its sub-expressions.
fn lower_to_value_and_bindings<'def>(
    ctx: &mut LoweringContext<'def>,
    expr: &'def TypedExpr,
    defs: &'def TypedDefinitions,
) -> (HirValue, Vec<BindingData>) { // Use BindingData type alias
    let mut bindings = Vec::new();
    let span = expr.span;

    let value = match &expr.kind {
        TypedExprKind::Literal(lit) => {
            HirValue::Use(Operand::Const(lower_literal(lit)))
        }
        TypedExprKind::Variable { symbol, name: _ } => {
             if defs.functions.contains_key(symbol) {
                HirValue::Use(Operand::Global(*symbol))
            } else if let Some(var) = ctx.get_hir_var(*symbol) {
                 HirValue::Use(Operand::Var(var))
             } else {
                 // Should be registered before use via let or params
                 panic!("Lowering Error: Undefined variable {:?} used directly.", symbol);
             }
        }
        TypedExprKind::Paren(inner) => {
            // Recurse, add bindings, and return inner value.
            let (inner_value, inner_bindings) = lower_to_value_and_bindings(ctx, inner, defs);
            bindings.extend(inner_bindings); // Add bindings from the inner expression
            inner_value // Return only the value, bindings are added to the outer vector
        }
        TypedExprKind::Tuple(elements) => {
            let mut element_operands = Vec::with_capacity(elements.len());
            for elem_expr in elements {
                // Use lower_sub_expr_to_operand instead of the removed lower_to_operand
                let operand = lower_sub_expr_to_operand(elem_expr, ctx, defs, &mut bindings);
                element_operands.push(operand);
                // Removed push to binding_fns as lower_sub_expr_to_operand handles bindings directly
            }
            HirValue::Aggregate { kind: AggregateKind::Tuple, fields: element_operands }
        }
        TypedExprKind::Array(elements) => {
             let mut element_operands = Vec::with_capacity(elements.len());
            for elem_expr in elements {
                let operand = lower_sub_expr_to_operand(elem_expr, ctx, defs, &mut bindings);
                element_operands.push(operand);
            }
            HirValue::Aggregate { kind: AggregateKind::Array, fields: element_operands }
        }
         TypedExprKind::Struct { name, fields, base } => {
            // 1. Lower base expression if present
            let mut base_operand_opt: Option<Operand> = None;
            if let Some(base_expr) = base {
                let base_operand = lower_sub_expr_to_operand(base_expr, ctx, defs, &mut bindings);
                base_operand_opt = Some(base_operand);
            }
            
            let struct_def_symbol = ctx.definitions().structs.iter()
                .find(|(_, def)| def.name == *name)
                .map(|(sym, _)| *sym)
                .unwrap_or_else(|| panic!("Could not find struct definition for '{}' during HIR value lowering", name));
                
            let struct_def = &defs.structs[&struct_def_symbol];
            
            // 2. Lower explicitly provided fields
            let mut explicit_field_values = HashMap::with_capacity(fields.len());
            for (fname, fexpr) in fields {
                let operand = lower_sub_expr_to_operand(fexpr, ctx, defs, &mut bindings);
                explicit_field_values.insert(fname.clone(), operand);
            }
            
            // 3. & 4. Initialize ordered operands and fill, projecting from base if needed
            let mut ordered_operands = Vec::with_capacity(struct_def.fields.len());
            
            for field_def in struct_def.fields.iter() { // Removed enumerate idx
                if let Some(explicit_operand) = explicit_field_values.get(&field_def.name) {
                    // Use explicitly provided value
                    ordered_operands.push(explicit_operand.clone());
                } else if let Some(ref base_op) = base_operand_opt {
                    // Project from the base operand
                    let projection_value = HirValue::Project {
                        base: base_op.clone(),
                        projection: ProjectionKind::Field(field_def.symbol),
                    };
                    // Bind the projection to a temp var
                    let temp_var = ctx.fresh_hir_var();
                    let temp_var_ty = lower_type(&field_def.ty, ctx); // Use type from struct def field
                    // Push tuple
                    bindings.push((temp_var, temp_var_ty, projection_value));
                    // Use the temp var as the operand for this field
                    ordered_operands.push(Operand::Var(temp_var));
                } else {
                    // Field not provided and no base expression - should be caught by type checker
                     panic!("Missing field '{}' for struct '{}' with no base expression", field_def.name, name);
                }
            }
            
            // 5. Construct Aggregate
             HirValue::Aggregate { kind: AggregateKind::Struct(struct_def_symbol), fields: ordered_operands }
         }
         TypedExprKind::VariantConstructor { enum_name, variant_name, args } => {
             let enum_def_symbol = ctx.definitions().enums.iter()
                 .find(|(_, def)| def.name == *enum_name)
                 .map(|(sym, _)| *sym)
                 .unwrap_or_else(|| panic!("Could not find enum definition for '{}' during HIR value lowering", enum_name));
             let enum_def = &defs.enums[&enum_def_symbol];
             let variant_info = enum_def.variants.iter()
                 .find_map(|v| match v {
                     TypedVariant::Unit { name, symbol, .. } if name == variant_name => Some((*symbol, 0)),
                     TypedVariant::Tuple { name, symbol, types, .. } if name == variant_name => Some((*symbol, types.len())),
                     TypedVariant::Struct { name, symbol, fields,.. } if name == variant_name => Some((*symbol, fields.len())),
                     _ => None,
                 })
                 .unwrap_or_else(|| panic!("Could not find variant definition for '{}.{}' during HIR value lowering", enum_name, variant_name));
             let variant_symbol = variant_info.0;
             let expected_arg_count = variant_info.1;
             
             if args.len() != expected_arg_count {
                  panic!("Arg count mismatch for variant '{}.{}'", enum_name, variant_name);
              }
             
             let mut arg_operands = Vec::with_capacity(args.len());
             for arg in args {
                 let operand = lower_sub_expr_to_operand(&arg.value, ctx, defs, &mut bindings);
                 arg_operands.push(operand);
             }
             HirValue::Aggregate { kind: AggregateKind::EnumVariant(variant_symbol), fields: arg_operands }
         }
          TypedExprKind::Field { object, field_name, field_symbol } => {
             let base_operand = lower_sub_expr_to_operand(object, ctx, defs, &mut bindings);
             let base_ty = lower_type(&object.ty, ctx);
             let projection_kind = match base_ty {
                 HirType::Adt(struct_symbol) => {
                      // Check if it's actually a struct
                      if defs.structs.contains_key(&struct_symbol) {
                          // Use the resolved field_symbol directly
                          ProjectionKind::Field(*field_symbol)
                      } else {
                          panic!("Field projection on non-struct ADT Symbol: {:?}", struct_symbol);
                      }
                 }
                 HirType::Tuple(element_types) => {
                     // Tuple field access uses index
                     let index: u32 = field_name.parse().unwrap_or_else(|_| panic!("Invalid tuple index: {}", field_name));
                      if index < element_types.len() as u32 {
                         ProjectionKind::TupleIndex(index)
                     } else {
                         panic!("Tuple index out of bounds: {}", index);
                     }
                 }
                 // --- Fix: Handle Array Indexing ---
                 HirType::Array(..) => {
                     // Array indexing requires the index to be an operand.
                     // If field_name parses as an integer, use that as a Const operand.
                     // Otherwise, assume field_symbol refers to the index variable.
                     match field_name.parse::<i64>() {
                         Ok(index_lit) => ProjectionKind::ArrayIndex(Operand::Const(HirLiteral::Int(index_lit))),
                         Err(_) => {
                             // field_name is not a literal index, assume field_symbol is the index variable
                             if let Some(index_var) = ctx.get_hir_var(*field_symbol) {
                                 ProjectionKind::ArrayIndex(Operand::Var(index_var))
                             } else {
                                 // If field_symbol is also not a variable in context, it's an error.
                                 // This indicates a potential issue upstream (e.g., type checking or AST generation).
                                 panic!(
                                     "Lowering Error: Cannot lower array index. `field_name` ('{}') is not a literal index, and `field_symbol` ({:?}) is not a known variable in the current context.",
                                     field_name, field_symbol
                                 );
                             }
                         }
                     }
                 }
                 // --- End Fix ---
                 _ => panic!("Field projection on invalid base type: {:?}", base_ty),
             };
             HirValue::Project { base: base_operand, projection: projection_kind }
         }
        
        TypedExprKind::Call { func, args } => {
            let func_operand = lower_sub_expr_to_operand(func, ctx, defs, &mut bindings);
            let mut arg_operands = Vec::with_capacity(args.len());
            for arg in args {
                 let arg_operand = lower_sub_expr_to_operand(&arg.value, ctx, defs, &mut bindings);
                 arg_operands.push(arg_operand);
             }
            HirValue::Call { func: func_operand, args: arg_operands }
        }

        // --- Fix: Handle Lambda Directly Here --- 
        TypedExprKind::Lambda { params, body } => {
            // 1. Analyze captures
            let captures = analyze_captures(ctx, body);

            // 2. Generate symbol for the lambda's HirFunction
            let lambda_fn_symbol = ctx.fresh_symbol();

            // 3. Generate the HirFunction for the lambda body
            let lambda_hir_fn = generate_lambda_function(
                ctx, defs, lambda_fn_symbol, expr.span, params, &captures, body,
            );
            ctx.generated_lambda_functions.push(lambda_hir_fn);

            // 4. Create Closure value or direct Function Pointer
            if captures.is_empty() {
                // No captures, directly use the function pointer
                HirValue::Use(Operand::Global(lambda_fn_symbol))
            } else {
                // Captures exist, create a closure object
                let mut capture_operands = Vec::with_capacity(captures.len());
                for (capture_symbol, _) in &captures {
                    // Get the HirVar for the captured variable from the current context
                    let hir_var = ctx.get_hir_var(*capture_symbol)
                        .unwrap_or_else(|| panic!("Lowering Error: Captured variable {:?} not found in outer context.", capture_symbol));
                    capture_operands.push(Operand::Var(hir_var));
                }
                HirValue::Closure {
                    function_symbol: lambda_fn_symbol,
                    captures: capture_operands,
                }
            }
        }
        // --- End Fix ---

        // Block is now handled in lower_expression
        // TypedExprKind::Block(exprs) => { ... }

        // Non-Value Expressions: These should be handled by `lower_expression`'s main match
        TypedExprKind::Let { .. } |
        TypedExprKind::If { .. } |
        TypedExprKind::Match { .. } |
        TypedExprKind::LogicalAnd { .. } |
        TypedExprKind::LogicalOr { .. } |
        TypedExprKind::Error | // Error should not be lowered
        TypedExprKind::Block { .. } => { // Block is handled in lower_expression
            panic!("lower_to_value_and_bindings called on non-value or control-flow expression: {:?}", expr.kind);
        }
        // Removed Lambda from here, moved above
    };

    // Return the value and all accumulated bindings
    (value, bindings)
}

/// Main lowering function: Constructs the complete HirExpr.
pub(super) fn lower_expression<'def>(
    ctx: &mut LoweringContext<'def>,
    expr: &'def TypedExpr,
    defs: &'def TypedDefinitions,
) -> HirExpr {
    let span = expr.span;
    let final_hir_ty = lower_type(&expr.ty, ctx);

    match &expr.kind {
        // Let is handled specially here
        TypedExprKind::Let { pattern, value } => {
            let mut value_bindings = Vec::new();
            let value_operand = lower_sub_expr_to_operand(value, ctx, defs, &mut value_bindings);

            // pattern_bindings_data is Vec<(HirVar, HirType, HirValue)>
            let pattern_bindings = lower_pattern_binding(ctx, pattern, value_operand, defs);
            // Note: pattern_bindings are already in BindingData format: (HirVar, HirType, HirValue)

            // Assume Let expr evaluates to Unit if it's not the tail expr of a block/func.
            // This is handled correctly by the revised Block lowering.
            let body_expr = HirExpr {
                kind: HirExprKind::Tail(HirTailExpr::Return(Operand::Const(HirLiteral::Unit))),
                 ty: HirType::Tuple(vec![]), // Unit type
                 span, // Use Let's span for the implicit Unit return
             };

            let mut all_bindings = value_bindings;
            all_bindings.extend(pattern_bindings);

            // Construct the nested Let expression
            build_nested_lets(all_bindings, body_expr, span)
        }

        // --- Control Flow ---
        TypedExprKind::If { condition, then_branch, else_branch } => {
             let mut cond_bindings = Vec::new();
             let cond_operand = lower_sub_expr_to_operand(condition, ctx, defs, &mut cond_bindings);

             // Lower branches recursively
             let then_expr = lower_expression(ctx, then_branch, defs);
             let else_expr = match else_branch {
                 Some(else_b) => lower_expression(ctx, else_b, defs),
                 // If no else branch, it implicitly returns Unit.
                 None => HirExpr {
                     kind: HirExprKind::Tail(HirTailExpr::Return(Operand::Const(HirLiteral::Unit))),
                     ty: HirType::Tuple(vec![]), // Unit type
                     span: condition.span, // Span might need adjustment
                 }
             };

             // --- Always bind condition result ---
             let cond_var = ctx.fresh_hir_var();
             let cond_hir_ty = lower_type(&condition.ty, ctx); // Get condition's type
             cond_bindings.push((cond_var, cond_hir_ty, HirValue::Use(cond_operand)));
             // --- End Fix ---

             // Wrap the tail If expression with bindings for the condition
             let tail_if_expr = HirExpr {
                 kind: HirExprKind::Tail(HirTailExpr::If {
                     condition: Operand::Var(cond_var), // Use the bound var
                     then_branch: Box::new(then_expr),
                     else_branch: Box::new(else_expr),
                 }),
                 ty: final_hir_ty, // Type should be unified by type checker
                 span,
             };

             build_nested_lets(cond_bindings, tail_if_expr, span)
        }

        TypedExprKind::LogicalAnd { left, right } => {
            // Desugar `a && b` into `if a { b } else { false }`
            let mut cond_bindings = Vec::new();
            let cond_operand = lower_sub_expr_to_operand(left, ctx, defs, &mut cond_bindings);

            let then_expr = lower_expression(ctx, right, defs); // Evaluate right if left is true
            let else_expr = HirExpr { // Return false if left is false
                 kind: HirExprKind::Tail(HirTailExpr::Return(Operand::Const(HirLiteral::Bool(false)))),
                 ty: HirType::Primitive(ResolvePrimitiveType::Bool),
                 span: left.span, // Adjust span?
             };

             // --- Always bind condition result ---
             let cond_var = ctx.fresh_hir_var();
             let cond_hir_ty = lower_type(&left.ty, ctx); // Get type of 'a'
             cond_bindings.push((cond_var, cond_hir_ty, HirValue::Use(cond_operand)));
             // --- End Fix ---

             let tail_if_expr = HirExpr {
                 kind: HirExprKind::Tail(HirTailExpr::If {
                     condition: Operand::Var(cond_var), // Use bound var
                     then_branch: Box::new(then_expr),
                     else_branch: Box::new(else_expr),
                 }),
                 ty: final_hir_ty, // Should be Bool
                 span,
             };

             build_nested_lets(cond_bindings, tail_if_expr, span)
        }
         TypedExprKind::LogicalOr { left, right } => {
            // Desugar `a || b` into `if a { true } else { b }`
            let mut cond_bindings = Vec::new();
            let cond_operand = lower_sub_expr_to_operand(left, ctx, defs, &mut cond_bindings);

             let then_expr = HirExpr { // Return true if left is true
                 kind: HirExprKind::Tail(HirTailExpr::Return(Operand::Const(HirLiteral::Bool(true)))),
                 ty: HirType::Primitive(ResolvePrimitiveType::Bool),
                 span: left.span, // Adjust span?
             };
            let else_expr = lower_expression(ctx, right, defs); // Evaluate right if left is false

             // --- Always bind condition result ---
             let cond_var = ctx.fresh_hir_var();
             let cond_hir_ty = lower_type(&left.ty, ctx); // Get type of 'a'
             cond_bindings.push((cond_var, cond_hir_ty, HirValue::Use(cond_operand)));
             // --- End Fix ---

             let tail_if_expr = HirExpr {
                 kind: HirExprKind::Tail(HirTailExpr::If {
                     condition: Operand::Var(cond_var), // Use bound var
                     then_branch: Box::new(then_expr),
                     else_branch: Box::new(else_expr),
                 }),
                 ty: final_hir_ty, // Should be Bool
                 span,
             };

             build_nested_lets(cond_bindings, tail_if_expr, span)
        }

        TypedExprKind::Match { scrutinee, arms } => {
            // First, lower scrutinee and collect bindings
            let mut scrutinee_bindings = Vec::new();
            let scrutinee_operand = lower_sub_expr_to_operand(scrutinee, ctx, defs, &mut scrutinee_bindings);

            // Lower each match arm: pattern and body
            let mut hir_arms = Vec::new();
            let mut hir_otherwise: Option<Box<HirExpr>> = None;
            // let match_span = span; // Capture span for use inside loop - not used?

            let num_arms = arms.len();
            let mut last_arm_is_wildcard = false;

            // Check if the last arm is a catch-all wildcard or identifier binding
            if let Some(last_arm) = arms.last() {
                match last_arm.pattern.kind {
                    TypedPatternKind::Wildcard | TypedPatternKind::Identifier { .. } => {
                        last_arm_is_wildcard = true;
                    }
                    _ => {}
                }
            }

            // Iterate through arms, excluding the last one if it's a wildcard
            let arms_to_process = if last_arm_is_wildcard { &arms[..num_arms-1] } else { &arms[..] };

            for arm in arms_to_process {
                let arm_span = arm.pattern.span; // Span for bindings originating from this arm's pattern
                ctx.push_scope();
                // Lower the arm's pattern and body (existing logic)
                let (arm_hir_pattern, arm_hir_body) = match &arm.pattern.kind {
                    // --- Desugar Complex Patterns ---
                    TypedPatternKind::Tuple(elements) => {
                        let mut arm_specific_bindings = Vec::new();
                        for (i, element_pattern) in elements.iter().enumerate() {
                            // Project element
                            let proj_val = HirValue::Project {
                                base: scrutinee_operand.clone(),
                                projection: ProjectionKind::TupleIndex(i as u32),
                            };
                            let proj_var = ctx.fresh_hir_var();
                            let proj_var_ty = lower_type(&element_pattern.ty, ctx);
                            arm_specific_bindings.push((proj_var, proj_var_ty, proj_val));
                            // Handle bindings within the element pattern
                            let sub_bindings = lower_pattern_binding(ctx, element_pattern, Operand::Var(proj_var), defs);
                            arm_specific_bindings.extend(sub_bindings);
                        }
                        let original_body = lower_expression(ctx, &arm.body, defs);
                        let wrapped_body = build_nested_lets(arm_specific_bindings, original_body, arm_span);
                        (HirPattern::Wildcard, wrapped_body)
                    }
                    TypedPatternKind::Struct { struct_name, fields, .. } => {
                        let mut arm_specific_bindings = Vec::new();
                        let struct_def = ctx.definitions().structs.values().find(|s| s.name == *struct_name)
                            .unwrap_or_else(|| panic!("Struct '{}' not found for match pattern lowering", struct_name));
                        for field_pattern_info in fields {
                            let field_def = struct_def.fields.iter()
                                .find(|f| f.name == field_pattern_info.name)
                                .unwrap_or_else(|| panic!("Field '{}' not found in struct '{}' for match pattern lowering", field_pattern_info.name, struct_name));
                            let field_symbol = field_def.symbol;
                            let proj_val = HirValue::Project {
                                base: scrutinee_operand.clone(),
                                projection: ProjectionKind::Field(field_symbol),
                            };
                            let proj_var = ctx.fresh_hir_var();
                            let proj_var_ty = lower_type(&field_def.ty, ctx);
                            arm_specific_bindings.push((proj_var, proj_var_ty, proj_val));
                            if let Some(sub_pattern) = &field_pattern_info.pattern {
                                let sub_bindings = lower_pattern_binding(ctx, sub_pattern, Operand::Var(proj_var), defs);
                                arm_specific_bindings.extend(sub_bindings);
                            } else {
                                ctx.add_binding_with_type(field_symbol, proj_var, field_def.ty.clone());
                            }
                        }
                        let original_body = lower_expression(ctx, &arm.body, defs);
                        let wrapped_body = build_nested_lets(arm_specific_bindings, original_body, arm_span);
                        (HirPattern::Wildcard, wrapped_body)
                    }
                    TypedPatternKind::Array(elements) => {
                        let mut arm_specific_bindings = Vec::new();
                        for (i, element_pattern) in elements.iter().enumerate() {
                            let index_operand = Operand::Const(HirLiteral::Int(i as i64));
                            let proj_val = HirValue::Project {
                                base: scrutinee_operand.clone(),
                                projection: ProjectionKind::ArrayIndex(index_operand),
                            };
                            let proj_var = ctx.fresh_hir_var();
                            let proj_var_ty = lower_type(&element_pattern.ty, ctx);
                            arm_specific_bindings.push((proj_var, proj_var_ty, proj_val));
                            let sub_bindings = lower_pattern_binding(ctx, element_pattern, Operand::Var(proj_var), defs);
                            arm_specific_bindings.extend(sub_bindings);
                        }
                        let original_body = lower_expression(ctx, &arm.body, defs);
                        let wrapped_body = build_nested_lets(arm_specific_bindings, original_body, arm_span);
                        (HirPattern::Wildcard, wrapped_body)
                    }
                    // --- Simple Patterns (handled by lower_pattern) ---
                    _ => {
                        let (simple_hir_pattern, pattern_bindings) = lower_pattern(ctx, &arm.pattern, defs);
                        for (symbol, hir_var, ty) in pattern_bindings {
                            ctx.add_binding_with_type(symbol, hir_var, ty);
                        }
                        let original_body = lower_expression(ctx, &arm.body, defs);
                        (simple_hir_pattern, original_body)
                    }
                };
                ctx.pop_scope();
                hir_arms.push((arm_hir_pattern, arm_hir_body));
            }

            // Process the last arm separately if it was a wildcard
            if last_arm_is_wildcard {
                if let Some(last_arm) = arms.last() {
                    ctx.push_scope(); // Need scope for potential bindings in the wildcard arm itself (e.g., `x => ...`)
                    
                    // Handle potential binding in the wildcard/identifier arm (e.g., `x => ...`)
                    // We need to add the binding to the context *before* lowering the body.
                    match &last_arm.pattern.kind {
                        TypedPatternKind::Identifier { .. } => {
                            // Use lower_pattern to get the binding info (Symbol, HirVar, Ty)
                            let (_, pattern_bindings) = lower_pattern(ctx, &last_arm.pattern, defs);
                            if let Some((symbol, hir_var, ty)) = pattern_bindings.into_iter().next() {
                                // Add the binding for the identifier `x` to the context
                                ctx.add_binding_with_type(symbol, hir_var, ty);
                            } else {
                                panic!("Internal Error: lower_pattern for Identifier did not return binding info.");
                            }
                        }
                        TypedPatternKind::Wildcard => {
                            // No binding needed for `_`
                        }
                        _ => {
                             panic!("Internal Error: last_arm_is_wildcard check mismatch with actual pattern kind: {:?}", last_arm.pattern.kind);
                        }
                    }
                    
                    // Lower the body of the wildcard arm (bindings are now in context)
                    let otherwise_body = lower_expression(ctx, &last_arm.body, defs);
                    hir_otherwise = Some(Box::new(otherwise_body));
                    ctx.pop_scope();
                }
            }

            // --- Fix: Bind scrutinee operand if it's not already a simple Var --- 
            let final_scrutinee_operand;
            if !matches!(scrutinee_operand, Operand::Var(_)) {
                 let scrutinee_var = ctx.fresh_hir_var();
                 let scrutinee_ty = lower_type(&scrutinee.ty, ctx);
                 scrutinee_bindings.push((scrutinee_var, scrutinee_ty, HirValue::Use(scrutinee_operand)));
                 final_scrutinee_operand = Operand::Var(scrutinee_var);
            } else {
                 final_scrutinee_operand = scrutinee_operand;
            }
            // --- End Fix ---

            // Create the Match expression
            let match_expr = HirExpr {
                kind: HirExprKind::Tail(HirTailExpr::Match {
                    scrutinee: final_scrutinee_operand,
                    arms: hir_arms,
                    otherwise: hir_otherwise,
                }),
                ty: final_hir_ty,
                span,
            };

            // Wrap with any bindings needed for the scrutinee
            build_nested_lets(scrutinee_bindings, match_expr, span)
        }

        // Handle Block expressions - *** REVISED LOGIC ***
        TypedExprKind::Block(exprs) => {
            if exprs.is_empty() {
                // Empty block returns Unit
                return HirExpr {
                    kind: HirExprKind::Tail(HirTailExpr::Return(Operand::Const(HirLiteral::Unit))),
                    ty: HirType::Tuple(vec![]),
                    span,
                };
            }

            // Create a new scope for the block
            ctx.push_scope();

            let mut all_bindings = Vec::new();
            let num_stmts = exprs.len() - 1;

            // Process statements sequentially (except the last expression)
            for stmt_expr in exprs.iter().take(num_stmts) {
                let stmt_span = stmt_expr.span;
                match &stmt_expr.kind {
                    TypedExprKind::Let { pattern, value } => {
                        let mut value_bindings = Vec::new();
                        let value_operand = lower_sub_expr_to_operand(value, ctx, defs, &mut value_bindings);
                        let pattern_bindings = lower_pattern_binding(ctx, pattern, value_operand, defs);

                        // Add bindings to the list for this block
                        all_bindings.extend(value_bindings);
                        all_bindings.extend(pattern_bindings);
                    }
                    _ => {
                        // Lower other statement types (e.g., calls for side effects)
                        let stmt_as_hir_expr = lower_expression(ctx, stmt_expr, defs);
                        let (stmt_bindings, stmt_tail) = flatten_hir_expr(stmt_as_hir_expr);
                        all_bindings.extend(stmt_bindings); // Add any bindings from the statement

                        // Ensure the statement's result (if not Unit) is bound to a dummy var
                        if let HirTailExpr::Return(operand) = stmt_tail {
                            let stmt_type = lower_type(&stmt_expr.ty, ctx);
                            if !matches!(stmt_type, HirType::Tuple(ref v) if v.is_empty()) {
                                let dummy_var = ctx.fresh_hir_var();
                                all_bindings.push((dummy_var, stmt_type, HirValue::Use(operand)));
                            }
                        } else if !matches!(stmt_tail, HirTailExpr::Never) {
                            // This should not happen if the type system enforces statements have types
                            // or if non-Let statements are restricted (e.g., only calls).
                            panic!("Lowering Error: Non-Let, non-Call statement found mid-block without returning a value? Span: {:?}", stmt_span);
                        }
                        // If stmt_tail is Never, we don't add more bindings, but the `Never` effect propagates.
                    }
                }
            }

            // Lower the final expression of the block
            let final_expr = lower_expression(ctx, exprs.last().unwrap(), defs);

            // Pop the scope for the block
            ctx.pop_scope();

            // Wrap the final expression with all the bindings collected from the statements
            build_nested_lets(all_bindings, final_expr, span)
        }

        TypedExprKind::Error => {
            // Type errors should be caught before HIR lowering.
            unreachable!("Error type encountered during HIR lowering at span {:?}", span);
        }

        // --- Expressions producing a value (handled by helper) ---
        _ => {
            // This path handles: Literal, Variable, Paren, Tuple, Array, Struct,
            // VariantConstructor, Field, Call.
            // Lambda is handled directly in lower_to_value_and_bindings.
            let (hir_value, mut bindings) = lower_to_value_and_bindings(ctx, expr, defs);

            // Determine the final expression: either return the operand directly
            // or bind the computed value and return the variable.
            let final_tail_expr;
            match hir_value {
                HirValue::Use(op) => {
                    // Value was already simple, return it directly.
                    final_tail_expr = HirExpr {
                        kind: HirExprKind::Tail(HirTailExpr::Return(op)),
                        ty: final_hir_ty.clone(),
                        span,
                    };
                }
                _ => {
                    // The value was complex (e.g., Aggregate, Call, Closure), bind it.
                    let result_var = ctx.fresh_hir_var();
                    bindings.push((result_var, final_hir_ty.clone(), hir_value));
                    final_tail_expr = HirExpr {
                        kind: HirExprKind::Tail(HirTailExpr::Return(Operand::Var(result_var))),
                        ty: final_hir_ty.clone(),
                        span,
                    };
                }
            }

            // Construct the final nested Let expression from all bindings.
            build_nested_lets(bindings, final_tail_expr, span)
        }
    }
}

/// Helper function to construct nested Let expressions.
fn build_nested_lets(bindings: Vec<BindingData>, final_expr: HirExpr, _span: SourceSpan) -> HirExpr { // Use BindingData, span ignored for now
    let mut current_expr = final_expr;
    for (var, var_ty, value) in bindings.into_iter().rev() {
        // Use the span of the expression being wrapped for the outer Let span
        let outer_span = current_expr.span;
        let outer_ty = current_expr.ty.clone(); // Type propagates from inner expr
        current_expr = HirExpr {
             kind: HirExprKind::Let {
                 var,
                 var_ty, // Type of the bound variable itself
                 value: Box::new(value),
                 rest: Box::new(current_expr),
             },
             ty: outer_ty, // Type of the overall expression
             span: outer_span, // Use outer span for nested Lets
         };
    }
    current_expr
}

/// Helper to decompose an HirExpr into bindings and the final tail expression.
/// Note: This consumes the expression.
fn flatten_hir_expr(expr: HirExpr) -> (Vec<BindingData>, HirTailExpr) {
    let mut bindings = Vec::new();
    let mut current_expr = expr;

    loop {
        match current_expr.kind {
            HirExprKind::Let { var, var_ty, value, rest } => {
                bindings.push((var, var_ty, *value));
                current_expr = *rest;
            }
            HirExprKind::Tail(tail_expr) => {
                // Reverse bindings to maintain original order for build_nested_lets
                bindings.reverse();
                return (bindings, tail_expr);
            }
        }
    }
}

/// Information about a captured variable.
#[derive(Debug, Clone)]
struct CaptureInfo {
    symbol: TypeSymbol, // Symbol from the typed AST
    ty: Ty,             // Type of the captured variable
    span: SourceSpan,   // Span where capture occurs (first usage)
}

/// Analyzes an expression to find free variables (symbols defined outside the expression)
fn analyze_captures(ctx: &LoweringContext, body: &TypedExpr) -> Vec<(TypeSymbol, Ty)> {
    let mut free_vars = HashSet::new();
    let mut defined_vars_stack: Vec<HashSet<TypeSymbol>> = vec![HashSet::new()]; // Track defined vars per scope within the lambda

    find_free_variables_recursive(ctx, body, &mut defined_vars_stack, &mut free_vars);

    // --- DEBUG --- 
    println!("[analyze_captures] Found potential free vars: {:?}", free_vars);
    // ------------- 

    // Convert the set of free variable symbols and their types into a Vec
    let captures: Vec<(TypeSymbol, Ty)> = free_vars
        .into_iter()
        .filter_map(|symbol| {
            // Get the HirVar and original Ty from the outer context
            let hir_var_opt = ctx.get_hir_var(symbol);
            let ty_opt = ctx.get_type_for_symbol(symbol);

            match (hir_var_opt, ty_opt) {
                (Some(_), Some(ty)) => {
                    // Both HirVar and Ty found, this is a valid capture
                    Some((symbol, ty))
                }
                (Some(_), None) => {
                    // HirVar found but Ty missing - indicates an internal inconsistency
                    // Should not happen if add_binding_with_type is used correctly everywhere.
                    panic!(
                        "Lowering Error: Found HirVar but no Ty for captured symbol {:?}. Check binding registration.",
                        symbol
                    );
                    // None // Or return None to skip if panic is too harsh
                }
                (None, Some(_)) => {
                    // Ty found but HirVar missing - indicates an internal inconsistency
                    panic!(
                        "Lowering Error: Found Ty but no HirVar for captured symbol {:?}. Check binding registration.",
                        symbol
                    );
                    // None
                }
                (None, None) => {
                    // Neither found - this symbol was likely identified as potentially free
                    // but wasn't actually defined in the outer context accessible to the lambda.
                    // This can happen if `find_free_variables_recursive` adds a symbol
                    // that's truly undefined (should be caught by type checker).
                    // We filter these out silently.
                    None
                }
            }
        })
        .collect();
    
    // --- DEBUG --- 
    println!("[analyze_captures] Filtered captures: {:?}", captures.iter().map(|(s,_)|s).collect::<Vec<_>>());
    // ------------- 

    captures
}

/// Recursive helper to find free variables in an expression relative to the current definition context.
fn find_free_variables_recursive(
    ctx: &LoweringContext, // Read-only access to outer context for checking if var is defined *outside*
    expr: &TypedExpr,
    defined_vars_stack: &mut Vec<HashSet<TypeSymbol>>, // Variables defined *within* the lambda
    free_vars: &mut HashSet<TypeSymbol>, // Accumulator for free variables
) {
    // --- DEBUG --- 
    let depth = defined_vars_stack.len(); // For indentation
    let indent = "  ".repeat(depth);
    println!("{}[find_free] Visiting expr kind: {:?}", indent, expr.kind);
    // ------------- 

    match &expr.kind {
        TypedExprKind::Variable { symbol, .. } => {
            println!("{}[find_free]   Found Variable: {:?}", indent, symbol);
            // Check if the variable is defined within the current lambda scope stack
            let is_defined_locally = defined_vars_stack.iter().rev().any(|scope| scope.contains(symbol));
            println!("{}[find_free]     Is defined locally?: {}", indent, is_defined_locally);

            if !is_defined_locally {
                // If not defined locally, it *might* be a free variable (capture candidate).
                // We only add it if it's actually defined in the *outer* context (checked by LoweringContext).
                let is_in_outer_ctx = ctx.get_hir_var(*symbol).is_some();
                 println!("{}[find_free]     Is in outer context?: {}", indent, is_in_outer_ctx);
                if is_in_outer_ctx {
                    println!("{}[find_free]     -> Adding {:?} to free vars", indent, symbol);
                    free_vars.insert(*symbol);
                }
                // If ctx.get_hir_var is None, it means it's an undefined variable,
                // which should have been caught by the type checker. We ignore it here.
            }
        }
        TypedExprKind::Block(exprs) => {
            // Create a new scope for the block
            defined_vars_stack.push(HashSet::new()); // Enter block scope
            
            // Process each expression in the block sequentially
            for stmt in exprs {
                // Process the expression to find any free variables
                find_free_variables_recursive(ctx, stmt, defined_vars_stack, free_vars);
                
                // Check if the statement introduces new bindings (Let expressions)
                // and add them to the current block scope for subsequent expressions
                if let TypedExprKind::Let { pattern, .. } = &stmt.kind {
                    let current_scope = defined_vars_stack.last_mut().unwrap();
                    collect_pattern_bindings(pattern, current_scope);
                }
            }
            
            // Cleanup: Remove the block's scope when we're done with it
            defined_vars_stack.pop(); // Exit block scope
        }
        TypedExprKind::If { condition, then_branch, else_branch } => {
            find_free_variables_recursive(ctx, condition, defined_vars_stack, free_vars);
            find_free_variables_recursive(ctx, then_branch, defined_vars_stack, free_vars);
            if let Some(else_b) = else_branch {
                find_free_variables_recursive(ctx, else_b, defined_vars_stack, free_vars);
            }
        }
        TypedExprKind::Match { scrutinee, arms } => {
            find_free_variables_recursive(ctx, scrutinee, defined_vars_stack, free_vars);
            for arm in arms {
                defined_vars_stack.push(HashSet::new()); // Enter arm scope
                let current_scope = defined_vars_stack.last_mut().unwrap();
                collect_pattern_bindings(&arm.pattern, current_scope); // Add pattern bindings
                find_free_variables_recursive(ctx, &arm.body, defined_vars_stack, free_vars);
                defined_vars_stack.pop(); // Exit arm scope
            }

        }
        TypedExprKind::Let { pattern, value } => {
            // Analyze value first (uses variables from outer scope)
            find_free_variables_recursive(ctx, value, defined_vars_stack, free_vars);
            // Add bindings from pattern to the *current* innermost scope for subsequent expressions
            let current_scope = defined_vars_stack.last_mut().unwrap();
            collect_pattern_bindings(pattern, current_scope);
        }
        TypedExprKind::Lambda { params, body } => {
            // Nested lambda: Define a new scope for its parameters.
            // Free variables within the nested lambda's body that are defined
            // in the *outer* lambda's scope are *not* captures for the outer lambda.
            defined_vars_stack.push(HashSet::new());
            let nested_scope = defined_vars_stack.last_mut().unwrap();
             for (param_symbol, _) in params {
                // We need the Symbol for the parameter. Assuming TypedExprKind::Lambda stores Symbols.
                // Let's assume `params` is Vec<(TypeSymbol, Ty)>)
                 nested_scope.insert(*param_symbol);
             }
            // Analyze nested body relative to its *own* scope + outer scopes
            find_free_variables_recursive(ctx, body, defined_vars_stack, free_vars);
            defined_vars_stack.pop(); // Exit nested lambda parameter scope
        }
        // Recurse into other expression kinds
        TypedExprKind::Call { func, args } => {
            find_free_variables_recursive(ctx, func, defined_vars_stack, free_vars);
            for arg in args { find_free_variables_recursive(ctx, &arg.value, defined_vars_stack, free_vars); }
        }
        TypedExprKind::Field { object, .. } => {
            find_free_variables_recursive(ctx, object, defined_vars_stack, free_vars);
        }
        TypedExprKind::Array(elements) | TypedExprKind::Tuple(elements) => {
            for elem in elements { find_free_variables_recursive(ctx, elem, defined_vars_stack, free_vars); }
        }
        TypedExprKind::Struct { fields, base, .. } => {
            for (_, field_expr) in fields { find_free_variables_recursive(ctx, field_expr, defined_vars_stack, free_vars); }
            if let Some(base_expr) = base { find_free_variables_recursive(ctx, base_expr, defined_vars_stack, free_vars); }
        }
         TypedExprKind::VariantConstructor { args, .. } => {
             for arg in args { find_free_variables_recursive(ctx, &arg.value, defined_vars_stack, free_vars); }
         }
        TypedExprKind::Paren(inner) => {
            find_free_variables_recursive(ctx, inner, defined_vars_stack, free_vars);
        }
         TypedExprKind::LogicalAnd { left, right } | TypedExprKind::LogicalOr { left, right }=> {
             find_free_variables_recursive(ctx, left, defined_vars_stack, free_vars);
             find_free_variables_recursive(ctx, right, defined_vars_stack, free_vars);
         }
        TypedExprKind::Literal(_) | TypedExprKind::Error => { /* No variables */ }
    }
}

/// Helper to recursively collect variable symbols defined by a pattern.
fn collect_pattern_bindings(pattern: &TypedPattern, scope: &mut HashSet<TypeSymbol>) {
    match &pattern.kind {
        TypedPatternKind::Identifier { symbol, name } if name != "_" => {
            scope.insert(*symbol);
        }
        TypedPatternKind::Tuple(elements) | TypedPatternKind::Array(elements) => {
            for elem in elements {
                collect_pattern_bindings(elem, scope);
            }
        }
        TypedPatternKind::Struct { fields, .. } => {
            for field in fields {
                if let Some(pat) = &field.pattern {
                    collect_pattern_bindings(pat, scope);
                } else {
                    // Add binding for shorthand { field } if TypedPatternField holds the symbol
                    // Assuming `field.symbol` exists and holds the TypeSymbol for the identifier `field`.
                    // This requires TypedPatternField to be updated in parallax-types.
                    // If not available, shorthand might need different handling or disallowing.
                    // scope.insert(field.symbol); // Uncomment if field.symbol is available
                }
            }
        }
        TypedPatternKind::Constructor { args, .. } => {
            // Assuming args is a single pattern (like Tuple for multiple args)
            collect_pattern_bindings(args, scope);
        }
        TypedPatternKind::Or(p1, p2) => {
            // Or patterns require careful handling - bindings might not be consistent.
            // Type checker should ideally prevent invalid Or patterns.
            // Assume bindings are consistent for now.
             let mut scope1 = HashSet::new();
             let mut scope2 = HashSet::new();
             collect_pattern_bindings(p1, &mut scope1);
             collect_pattern_bindings(p2, &mut scope2);
             // We should only add bindings present in *both* branches if required for soundness,
             // but let's assume the type checker ensured consistency and add all.
             scope.extend(scope1);
             scope.extend(scope2);

        }
        TypedPatternKind::Literal(_) | TypedPatternKind::Wildcard | TypedPatternKind::Rest | TypedPatternKind::Identifier { .. } => {
            // No nested bindings
        }
    }
}

/// Generates an HirFunction for a lambda's body.
fn generate_lambda_function<'def>(
    outer_ctx: &mut LoweringContext<'def>, // Use outer context for lowering body
    outer_defs: &'def TypedDefinitions,
    lambda_fn_symbol: Symbol, // Use TypeSymbol alias
    lambda_span: SourceSpan,
    params: &[(TypeSymbol, Ty)], // Original lambda params (Symbol + Type)
    captures: &[(TypeSymbol, Ty)], // Captured free variables (Symbol + Type)
    body: &'def TypedExpr, // Ensure body has 'def lifetime
) -> HirFunction {

    // Create a *new*, separate lowering context for the lambda body
    // to ensure variable mapping (symbol -> HirVar) is independent.
    let mut lambda_ctx = LoweringContext::new(outer_ctx.definitions()); // Share defs, but new var maps

    // --- Prepare Parameters for HIR function --- 
    let mut hir_params: Vec<(HirVar, HirType)> = Vec::new();
    // No need for lambda_body_scope HashMap, add_binding_with_type handles it.

    // 1. Add captured variables as the first parameters
    for (capture_symbol, capture_ty) in captures {
        let hir_var = lambda_ctx.fresh_hir_var();
        let hir_type = lower_type(capture_ty, &mut lambda_ctx); // Lower type in lambda's context
        hir_params.push((hir_var, hir_type));
        // Map the original capture symbol to the new HirVar AND store its Ty
        // *within the lambda's context*
        lambda_ctx.add_binding_with_type(*capture_symbol, hir_var, capture_ty.clone());
    }

    // 2. Add original lambda parameters
    for (param_symbol, param_ty) in params {
        let hir_var = lambda_ctx.fresh_hir_var();
        let hir_type = lower_type(param_ty, &mut lambda_ctx);
        hir_params.push((hir_var, hir_type));
         // Map the original param symbol to the new HirVar AND store its Ty
         // *within the lambda's context*
         lambda_ctx.add_binding_with_type(*param_symbol, hir_var, param_ty.clone());
    }

    // --- Lower Body ---
    // The body is lowered using the lambda's context, where captures and params are pre-defined.
    let hir_body = lower_expression(&mut lambda_ctx, body, outer_defs); // Use outer_defs

    // --- Create Signature ---
    let return_ty = hir_body.ty.clone(); // Return type is inferred from lowered body
    let signature = HirFunctionSignature {
        params: hir_params, // Use the HIR params generated above
        return_type: return_ty,
        is_effectful: analyze_hir_expr_for_effects(&hir_body),
    };

    // --- Create Function ---
    let lambda_fn = HirFunction {
        symbol: lambda_fn_symbol,
        name: format!("lambda_{}", lambda_fn_symbol.id()), // Generate unique name
        signature,
        body: Some(hir_body),
        span: lambda_span, // Use span of the original lambda expression
    };

    // Transfer any nested lambda functions generated during body lowering
    // from the lambda_ctx to the outer_ctx.
    outer_ctx.generated_lambda_functions.extend(lambda_ctx.generated_lambda_functions);

    lambda_fn
}

/// Analyzes an HIR expression recursively to determine if it might have side effects.
/// Currently, it flags any function call as potentially effectful.
/// TODO: Refine this to check if the called function itself is known to be effectful.
/// TODO: Refine this. Possibilities:
/// TODO: 1. Pass function signatures/definitions during analysis to check `is_effectful` flag for `Operand::Global` calls.
/// TODO: 2. Implement a separate post-lowering pass to determine and propagate effect information.
/// TODO: 3. Assume closures (`Operand::Var` as function) are potentially effectful unless proven otherwise.
fn analyze_hir_expr_for_effects(expr: &HirExpr) -> bool {
    match &expr.kind {
        HirExprKind::Let { value, rest, .. } => {
            // Check the bound value and the rest of the expression
            analyze_hir_value_for_effects(value) || analyze_hir_expr_for_effects(rest)
        }
        HirExprKind::Tail(tail_expr) => analyze_hir_tail_expr_for_effects(tail_expr),
    }
}

/// Helper to analyze HirValue for effects.
fn analyze_hir_value_for_effects(value: &HirValue) -> bool {
    match value {
        HirValue::Call { .. } => true, // Any call is potentially effectful
        HirValue::Aggregate { fields, .. } => fields.iter().any(analyze_operand_for_effects),
        HirValue::Project { base, .. } => analyze_operand_for_effects(base),
        HirValue::Closure { captures, .. } => captures.iter().any(analyze_operand_for_effects),
        HirValue::Use(operand) => analyze_operand_for_effects(operand),
    }
}

/// Helper to analyze HirTailExpr for effects.
fn analyze_hir_tail_expr_for_effects(tail_expr: &HirTailExpr) -> bool {
    match tail_expr {
        HirTailExpr::Return(operand) => analyze_operand_for_effects(operand),
        HirTailExpr::Match { scrutinee, arms, otherwise } => {
            analyze_operand_for_effects(scrutinee)
                || arms.iter().any(|(_, body)| analyze_hir_expr_for_effects(body))
                || otherwise.as_ref().map_or(false, |body| analyze_hir_expr_for_effects(body))
        }
        HirTailExpr::If { condition, then_branch, else_branch } => {
            analyze_operand_for_effects(condition)
                || analyze_hir_expr_for_effects(then_branch)
                || analyze_hir_expr_for_effects(else_branch)
        }
        HirTailExpr::Never => false,
    }
}

/// Helper to analyze Operand for effects (currently, only checks contained constants/vars - trivially false).
fn analyze_operand_for_effects(_operand: &Operand) -> bool {
    // match operand {
    //     Operand::Const(_) | Operand::Var(_) | Operand::Global(_) => false,
    // }
    false // Simplified
}

#[cfg(test)]
mod tests {
    use super::{lower_expression, lower_sub_expr_to_operand, lower_to_value_and_bindings};
    use crate::hir::{HirExpr, HirExprKind, HirValue, HirTailExpr, Operand, HirLiteral, HirType, ResolvePrimitiveType, HirVar, AggregateKind, ProjectionKind};
    use crate::lower::{LoweringContext, types::lower_type};
    use parallax_resolve::types::{Symbol, PrimitiveType as ResolvePrimitive};
    use parallax_syntax::ast::common::Literal as AstLiteral;
    use parallax_types::types::{Ty, TyKind, PrimitiveType, TypedExpr, TypedExprKind, TypedDefinitions, TypedArgument};
    use miette::SourceSpan;
    use std::collections::HashMap;
    use std::sync::Arc;

    // --- Test Helpers ---
    fn dummy_span() -> SourceSpan {
        SourceSpan::from((0, 0))
    }

    fn dummy_ty(kind: TyKind) -> Ty {
        Ty { kind, span: Some(dummy_span()) }
    }

    fn dummy_expr(kind: TypedExprKind, ty_kind: TyKind) -> TypedExpr {
        TypedExpr {
            kind,
            ty: dummy_ty(ty_kind),
            span: dummy_span(),
        }
    }

    fn create_test_context() -> LoweringContext<'static> {
        let defs = Box::leak(Box::new(TypedDefinitions::default()));
        LoweringContext::new(defs)
    }

    // --- lower_sub_expr_to_operand Tests ---

    #[test]
    fn test_sub_expr_to_operand_literal() {
        let mut ctx = create_test_context();
        let defs = TypedDefinitions::default();
        let mut bindings = Vec::new();
        let expr = dummy_expr(
            TypedExprKind::Literal(AstLiteral::Int(123)),
            TyKind::Primitive(PrimitiveType::I64)
        );

        let operand = lower_sub_expr_to_operand(&expr, &mut ctx, &defs, &mut bindings);

        assert_eq!(operand, Operand::Const(HirLiteral::Int(123)));
        assert!(bindings.is_empty());
    }

    #[test]
    fn test_sub_expr_to_operand_variable() {
        let mut ctx = create_test_context();
        let var_symbol = Symbol::new(5);
        let hir_var = ctx.get_or_create_hir_var(var_symbol);
        ctx.add_binding_with_type(var_symbol, hir_var, dummy_ty(TyKind::Primitive(PrimitiveType::Bool)));

        let defs = TypedDefinitions::default();
        let mut bindings = Vec::new();
        let expr = dummy_expr(
            TypedExprKind::Variable { symbol: var_symbol, name: "v".to_string() },
            TyKind::Primitive(PrimitiveType::Bool)
        );

        let operand = lower_sub_expr_to_operand(&expr, &mut ctx, &defs, &mut bindings);

        assert_eq!(operand, Operand::Var(hir_var));
        assert!(bindings.is_empty());
    }

    #[test]
    fn test_sub_expr_to_operand_complex() {
        // Test that a complex expression generates bindings and returns a Var
        let mut ctx = create_test_context();
        let defs = TypedDefinitions::default();
        let mut bindings = Vec::new();
        let expr = dummy_expr(
            TypedExprKind::Tuple(vec![ // A tuple is complex, needs binding
                 dummy_expr(TypedExprKind::Literal(AstLiteral::Int(1)), TyKind::Primitive(PrimitiveType::I32)),
                 dummy_expr(TypedExprKind::Literal(AstLiteral::Bool(true)), TyKind::Primitive(PrimitiveType::Bool)),
            ]),
            TyKind::Tuple(vec![dummy_ty(TyKind::Primitive(PrimitiveType::I32)), dummy_ty(TyKind::Primitive(PrimitiveType::Bool))])
        );

        let operand = lower_sub_expr_to_operand(&expr, &mut ctx, &defs, &mut bindings);

        assert_eq!(bindings.len(), 1); // Should create one binding for the tuple value
        let (bound_var, bound_ty, bound_value) = &bindings[0];
        // Check bound type and value
        assert_eq!(bound_ty, &HirType::Tuple(vec![HirType::Primitive(ResolvePrimitive::I32), HirType::Primitive(ResolvePrimitive::Bool)]));
        match bound_value {
            HirValue::Aggregate { kind: AggregateKind::Tuple, fields } => {
                assert_eq!(fields.len(), 2);
                assert_eq!(fields[0], Operand::Const(HirLiteral::Int(1)));
                assert_eq!(fields[1], Operand::Const(HirLiteral::Bool(true)));
            }
            _ => panic!("Expected Aggregate::Tuple, found {:?}", bound_value)
        }

        // Operand should be the variable bound to the tuple
        assert_eq!(operand, Operand::Var(*bound_var));
        // Check the HirVar ID. The first fresh_hir_var call happens inside lower_sub_expr_to_operand for the binding
        assert_eq!(bound_var, &HirVar(0));
    }

     // --- lower_to_value_and_bindings Tests ---

     #[test]
     fn test_lower_value_literal() {
        let mut ctx = create_test_context();
        let defs = TypedDefinitions::default();
        let expr = dummy_expr(
            TypedExprKind::Literal(AstLiteral::Bool(false)),
            TyKind::Primitive(PrimitiveType::Bool)
        );
        let (value, bindings) = lower_to_value_and_bindings(&mut ctx, &expr, &defs);

        assert_eq!(value, HirValue::Use(Operand::Const(HirLiteral::Bool(false))));
        assert!(bindings.is_empty());
     }

    #[test]
    fn test_lower_value_aggregate_tuple() {
        let mut ctx = create_test_context();
        let defs = TypedDefinitions::default();
        let lit1 = dummy_expr(TypedExprKind::Literal(AstLiteral::Int(1)), TyKind::Primitive(PrimitiveType::I32));
        let lit2 = dummy_expr(TypedExprKind::Literal(AstLiteral::Bool(true)), TyKind::Primitive(PrimitiveType::Bool));
        let expr = dummy_expr(
            TypedExprKind::Tuple(vec![lit1, lit2]),
            TyKind::Tuple(vec![dummy_ty(TyKind::Primitive(PrimitiveType::I32)), dummy_ty(TyKind::Primitive(PrimitiveType::Bool))])
        );

        let (value, bindings) = lower_to_value_and_bindings(&mut ctx, &expr, &defs);

        assert!(bindings.is_empty()); // Literals don't create bindings here
        match value {
             HirValue::Aggregate { kind: AggregateKind::Tuple, fields } => {
                 assert_eq!(fields.len(), 2);
                 assert_eq!(fields[0], Operand::Const(HirLiteral::Int(1)));
                 assert_eq!(fields[1], Operand::Const(HirLiteral::Bool(true)));
             }
             _ => panic!("Expected Aggregate::Tuple, found {:?}", value)
        }
    }

    #[test]
    fn test_lower_value_aggregate_with_bindings() {
        // Tuple where one element is complex and needs binding
        let mut ctx = create_test_context();
        let defs = TypedDefinitions::default();
        let complex_elem = dummy_expr( // Tuple expr
            TypedExprKind::Tuple(vec![
                dummy_expr(TypedExprKind::Literal(AstLiteral::Int(5)), TyKind::Primitive(PrimitiveType::I32))
            ]),
            TyKind::Tuple(vec![dummy_ty(TyKind::Primitive(PrimitiveType::I32))])
        );
        let simple_elem = dummy_expr(TypedExprKind::Literal(AstLiteral::Bool(false)), TyKind::Primitive(PrimitiveType::Bool));

        let expr = dummy_expr(
            TypedExprKind::Tuple(vec![complex_elem, simple_elem]),
            TyKind::Tuple(vec![
                dummy_ty(TyKind::Tuple(vec![dummy_ty(TyKind::Primitive(PrimitiveType::I32))])),
                dummy_ty(TyKind::Primitive(PrimitiveType::Bool))
            ])
        );

        let (value, bindings) = lower_to_value_and_bindings(&mut ctx, &expr, &defs);

        // Expect one binding for the inner complex_elem tuple
        assert_eq!(bindings.len(), 1);
        let (bound_var, _, bound_value) = &bindings[0];
        assert_eq!(bound_var, &HirVar(0)); // First binding gets ID 0
        match bound_value {
            HirValue::Aggregate { kind: AggregateKind::Tuple, fields } if fields.len() == 1 => {
                assert_eq!(fields[0], Operand::Const(HirLiteral::Int(5)));
            }
            _ => panic!("Expected inner binding for tuple, found {:?}", bound_value)
        }

        // The final value should be an aggregate using the bound var and the literal
        match value {
             HirValue::Aggregate { kind: AggregateKind::Tuple, fields } => {
                 assert_eq!(fields.len(), 2);
                 assert_eq!(fields[0], Operand::Var(*bound_var)); // Uses the bound variable (HirVar(0))
                 assert_eq!(fields[1], Operand::Const(HirLiteral::Bool(false)));
             }
             _ => panic!("Expected outer Aggregate::Tuple, found {:?}", value)
        }
    }

     // --- lower_expression Tests ---
     // TODO: Add tests for lower_expression (handling Let, If, Match, Block etc.)
}

