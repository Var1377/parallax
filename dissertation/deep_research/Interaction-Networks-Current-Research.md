The Current State of Research in Interaction Nets
1. Introduction
1.1. Overview
Interaction Nets (INs) represent a distinctive graphical model of computation rooted in the principles of graph rewriting.1 Introduced by the French mathematician Yves Lafont in 1990 2, INs offer a paradigm where computation unfolds through local transformations on graph structures. An interaction net system is defined by a collection of agent types (nodes) and a set of interaction rules governing how these agents transform when connected in specific ways.2 A defining characteristic of INs is their inherent capacity for distributed computation; reductions can occur concurrently in multiple parts of the net without the need for global synchronization mechanisms.2 This potential for massive parallelism stems directly from the model's fundamental properties, particularly strong confluence, which guarantees that the order of independent reduction steps does not affect the final result.2
1.2. Context and Motivation
The genesis of Interaction Nets lies in Lafont's efforts to generalize the proof structures of Jean-Yves Girard's Linear Logic, particularly multiplicative linear logic (MLL) proof nets.2 Linear Logic, with its focus on resources that must be used exactly once, provided the foundational concepts of linearity that are central to INs.2 Lafont sought a computational model that directly embodied the desirable properties observed in these proof structures, namely the locality of computation and the strong guarantee of confluence (determinism).3 The motivation was to create a computational language where parallel execution arises naturally from the model's structure, rather than being an imposed layer.2 This focus on local interactions and the resulting potential for parallelism positioned INs as a novel approach to computation, distinct from traditional sequential models like Turing machines or inherently synchronous models like cellular automata.
1.3. Report Objectives and Structure
This report aims to provide a comprehensive survey of the current state of research surrounding Interaction Nets. It begins by revisiting the foundational concepts defined by Lafont and then delves into the significant theoretical advancements, practical implementation techniques, and diverse applications that have emerged, with a particular focus on developments within the last five to ten years. The report will explore the theoretical underpinnings, including universal systems like interaction combinators, connections to semantics frameworks like the Geometry of Interaction, extensions developed to handle non-determinism and concurrency, and the role of type systems. It will then examine practical aspects, covering evaluators, compilers, implementation strategies like token-passing and in-place rewriting, and the development of higher-level programming languages built upon INs. Subsequently, the report surveys the key application domains, notably the implementation of functional languages (especially optimal reduction) and concurrency theory, alongside emerging areas like quantum computing and systems biology. Comparisons with other relevant computational models will be drawn to situate INs within the broader landscape. Finally, the report will identify the current challenges, known limitations, and prominent future research directions discussed in recent literature.
2. Foundations of Interaction Nets
2.1. Core Concepts
Interaction Nets are fundamentally graph-like structures built from a few basic components: agents, ports, and wires.2
* Agents, Ports, and Wires: An agent is a node within the net, characterized by a label (often referred to as its type or symbol) drawn from a predefined set called a signature, denoted by Σ.2 Each agent type has a fixed arity, which determines the number of connection points, or ports, it possesses.2 Crucially, every agent has exactly one principal port, often visually distinguished by an arrow, which is the site of potential interaction.1 The remaining ports are termed auxiliary ports.1 A net is formed by connecting these agents via wires (edges).1 A fundamental constraint is that each port can be connected to at most one wire, and each wire connects exactly two ports.2 Ports that remain unconnected are called free ports, and the collection of all free ports constitutes the interface of the net.2 Special cases include wirings, which are nets consisting only of edges with no agents, and the empty net.2
* Active Pairs and Interaction Rules: Computation in INs is driven by interactions between agents. An active pair is formed when two agents are connected to each other via their respective principal ports.1 This configuration represents a reducible expression, or redex, in the IN model.8 The behavior of active pairs is dictated by a set of interaction rules, denoted by R.2 An interaction rule specifies that an active pair formed by agents of types α and β, denoted (α, β), is rewritten (or reduced) into a new, generally more complex, interaction net, denoted N.2 This rewriting process is subject to strict constraints that underpin the model's desirable properties. Firstly, rules only apply to active pairs; agents connected via auxiliary ports do not interact directly.1 Secondly, for any given pair of agent types (α, β), there can be at most one interaction rule defined.1 This ensures deterministic reduction at the rule level. Thirdly, and crucially, the net N resulting from the rewrite must preserve the interface of the original active pair; that is, all auxiliary ports of the original α and β agents must connect to corresponding free ports in N, maintaining the connections to the rest of the graph.7 This property is often referred to as linearity. A net that contains no active pairs is said to be in normal form, representing the result of a computation.2
* Example: Unary Addition: A common introductory example is the representation of natural numbers in unary form and their addition.1 Natural numbers can be represented using two agent types: Z (Zero) of arity 0, and S (Successor) of arity 1. The number 0 is represented by a single Z agent. A number n>0 is represented by a chain of n S agents connected via their auxiliary and principal ports, terminated by a Z agent at one end. Addition can be implemented using an Add agent of arity 2. The interaction rules capture the standard recursive definition of addition:
   1. Add interacting with Z (representing 0+y): The active pair (Add, Z) rewrites to a simple wiring that connects the first auxiliary port of Add (representing y) directly to the result port (the second auxiliary port of Add). Add(u,y,z), Z(u) --> z-y.1
   2. Add interacting with S (representing S(x)+y): The active pair (Add, S) rewrites to a net containing a new S agent and a new Add agent, effectively implementing the step S(x)+y=S(x+y). Add(u,y,z), S(u,x) --> S(z,w), Add(x,y,w).1 Reduction proceeds by repeatedly applying these rules until the Add agent interacts with the Z agent of the first number, resulting in a net representing the sum.
2.2. Fundamental Properties
The strict constraints on interaction rules endow INs with several powerful properties that are crucial for their computational characteristics:
* Locality: Interaction rules are inherently local; a reduction step only modifies the two agents involved in the active pair and their immediate connections.2 The rest of the net remains unaffected during that specific step. This locality is a direct consequence of rules only applying to active pairs connected at principal ports.14
* Linearity: The requirement that interaction rules preserve the interface (the set of free ports connected to the auxiliary ports of the interacting agents) is a form of linearity.7 It ensures that connections to the surrounding net are maintained correctly during rewriting. A significant consequence is that each interaction rule application can be viewed as a constant-time operation, as the work involved in rewriting is bounded by the size of the rule's right-hand side, which is fixed for a given rule.1 This contrasts with operations like substitution in lambda calculus, whose cost can depend on the size of the term being substituted. This linearity implies that resources (connections) are neither implicitly duplicated nor deleted; such operations must be handled explicitly by dedicated agents if required.1
* Strong Confluence (One-Step Diamond Property): Interaction Nets possess the property of strong confluence, also known as the one-step diamond property.2 This means that if a net M can be reduced in one step to two different nets, M1​ and M2​ (by reducing different active pairs), then there must exist a net M3​ such that both M1​ and M2​ can be reduced to M3​ in exactly one step.2 This is a very strong form of determinism. It guarantees that the order in which concurrent reductions are performed does not influence the final result (if the computation terminates).6 All reduction sequences leading to a normal form will reach the same normal form, and importantly, they will have the same length.18
* Parallelism: The confluence and locality properties combine to make INs naturally suited for parallel computation.2 Since reductions are local and the order of independent reductions does not matter (due to strong confluence), multiple active pairs in different parts of the net can be reduced simultaneously without interfering with each other.2 No explicit synchronization mechanism is required to coordinate these parallel reductions; the confluence property mathematically guarantees the consistency of the computation.2 This "clockless" computation 16 is a major distinguishing feature and motivation for the IN model.
The guarantee of strong confluence is perhaps the most critical enabler of deterministic parallelism in INs. Because any local reduction choice ultimately leads to the same result after the same number of steps if multiple reductions are possible, computational agents can proceed independently without coordination. This mathematical assurance simplifies the conceptual model of parallel execution significantly, although practical parallel implementation still faces challenges. It's important to note that this inherent determinism means that standard INs cannot directly model non-deterministic processes; extensions are required for that purpose (see Section 3.3).
2.3. Relationship to Graph Rewriting
Interaction Nets can be understood as a specific, highly constrained instance of graph rewriting systems.1 General graph rewriting allows for complex rules that can match arbitrary subgraphs and perform extensive modifications. In contrast, INs impose strict limitations:
1. Binary Interaction: Rewriting occurs only between pairs of nodes (agents).21
2. Principal Port Interaction: Interaction is restricted to agents connected via their designated principal ports (forming an active pair).1
3. Linearity: Rules must preserve the external connections (free ports).4
4. Uniqueness: At most one rule is defined for each pair of interacting agent types.1
These restrictions significantly simplify the rewriting framework compared to general graph rewriting. However, this simplification comes with a major benefit: properties like strong confluence are guaranteed by construction for any valid IN system.12 In general graph rewriting, confluence is a property that needs to be proven for each specific system and often does not hold. Despite these constraints, INs remain computationally universal, meaning they can compute any function computable by a Turing machine.4 This demonstrates that the restrictions prune away complexity without sacrificing fundamental computational power, focusing instead on achieving desirable properties for parallel and distributed computation.
2.4. The Interaction Calculus
While the graphical representation of INs is intuitive, a textual formalism known as the Interaction Calculus was developed to provide a more rigorous and detailed definition of nets and their reduction.2 This calculus represents the wires or connections within a net using names (akin to variables).2 A key principle is linearity at the name level: each name appears at most twice within a given net representation.22 A name appearing once corresponds to a free port (part of the net's interface), while a name appearing twice represents an internal wire connecting two ports.3
Nets are represented as configurations, typically lists or multisets of agent terms and wiring equations.2 An agent term might look like α(x1​,...,xn​)∼y, where α is the agent type, x1​,...,xn​ are the names connected to the auxiliary ports, and y is the name connected to the principal port.24 An active pair is represented by two agent terms connected by the same name at their principal ports, often written using a special symbol like ~ or >< in rule definitions: α(...)∼z,β(...)∼z or α(...) >< β(...).22
Interaction rules are then expressed as transformations on these configurations. For example, a rule might be written as α(...) >< β(...)⇒N, where N is the textual representation of the resulting net configuration.22 The calculus defines reduction more precisely than graphical depictions, explicitly handling the wiring connections through name management.2 It includes rules for interaction (applying a rewrite rule to an active pair) and indirection or substitution (simplifying connections when a rule results in direct links between names).2 Like the lambda calculus, the Interaction Calculus incorporates the notion of α-conversion, meaning configurations are considered equivalent up to the consistent renaming of bound names.2
This textual formalism, while perhaps less immediately intuitive than the graphical view, is essential for formal analysis, proof development, and defining the operational semantics used in implementations.3 The visual nature of INs is powerful for conceptual understanding and high-level design 7, but the Interaction Calculus provides the necessary precision to handle the intricate details of graph manipulation during reduction, particularly the management of connections (port fusion).3 This highlights a recurring theme: a balance between the appealing graphical intuition and the need for rigorous, often less visual, formalisms for precise definition and implementation.
3. Theoretical Advancements and Formalisms
Building upon the foundational concepts, research in Interaction Nets has explored various theoretical avenues, including minimal universal systems, deeper semantic connections, extensions to the basic model, the development of type systems, and methods for complexity analysis.
3.1. Interaction Combinators
A significant theoretical development was Lafont's introduction of Interaction Combinators.1 This is a specific, minimal set of agents and interaction rules that is computationally universal for Interaction Nets.2 The standard set consists of three agent types (combinators), typically denoted:
* γ (gamma): A constructor agent (arity 2).
* δ (delta): A duplicator agent (arity 2).
* ε (epsilon): An eraser agent (arity 0). (Note: Some sources use different symbols or names, e.g., y, d, e 1 or variations like symmetric combinators 13)
These three agents interact according to six specific rules 1:
* Annihilation: When two agents of the same type interact via their principal ports, they annihilate each other, and their corresponding auxiliary ports are connected directly. Rules: (γγ), (δδ), (εε). (Note: ε has no auxiliary ports, so (εε) simply removes the pair). The connection patterns for (γγ) and (δδ) differ, with (γγ) typically swapping the connections.1
* Commutation: When two agents of different types interact, they essentially pass through each other, duplicating themselves and rearranging connections. Rules: (γδ), (γε), (δε).
The universality theorem states that any interaction net system, regardless of its complexity or the number of agent types, can be translated into an equivalent net composed solely of these three combinators and governed by these six rules.1 This demonstrates that the fundamental computational power of the interaction net paradigm lies in these basic operations of creation/signaling (γ), duplication (δ), and erasure (ε).
This universality provides a powerful theoretical tool, analogous to the SKI combinator calculus for lambda calculus. It establishes a minimal foundation for the model. However, much like SKI combinators, directly translating complex systems into interaction combinators often results in significantly larger nets and more reduction steps compared to using custom-designed, higher-level agents.6 This reveals a fundamental trade-off: the theoretical elegance and minimality of combinators versus the potential for greater efficiency using more specialized agent sets in practical implementations.
3.2. Connections to Logic and Semantics
The theoretical underpinnings of INs are deeply intertwined with logic and semantic frameworks, providing alternative perspectives on their computational meaning.
* Linear Logic: As mentioned earlier, INs originated as a generalization of proof nets for Multiplicative Linear Logic (MLL).2 Many IN systems directly encode MLL proof structures 23, and the core IN properties, especially linearity (resources are used exactly once unless explicitly duplicated or erased), directly reflect the resource-sensitive nature of linear logic.2 This connection provides a strong logical foundation for the model. Research continues to explore this relationship, for instance, through type systems based on deep inference in linear logic.30
* Geometry of Interaction (GoI): Introduced by Girard, GoI provides a dynamic interpretation of logic proofs, viewing computation as the circulation of information (often modeled as a token or signal) through a network representing the proof or program.3 Instead of focusing on term rewriting, GoI uses concepts from operator algebras or path semantics to describe the interaction flow.3 GoI has significantly influenced IN research in several ways. Firstly, it has inspired alternative formalizations of INs themselves, such as representing nets as partial permutations and reduction via an execution formula derived from GoI.3 Secondly, it has led to practical implementation techniques, most notably token-passing evaluators, where tokens traverse the net to guide reduction according to specific strategies.6 Thirdly, GoI frameworks have been developed specifically for interpreting interaction nets or their concurrent extensions.3
* Context Semantics (CS): Closely related to GoI, Context Semantics studies program evaluation by analyzing the paths traced by tokens moving through the program structure according to specific rules.13 It was initially applied to lambda calculus and linear logic for analyzing optimal reduction and complexity.13 This approach has been extended to the broader framework of INs, allowing the definition of context semantics for arbitrary IN libraries (agent sets and rules).13 Applications within INs include studying evaluation dynamics, defining observational equivalences, constructing denotational semantics for specific systems, and deriving complexity bounds.13
* Other Semantics: Beyond GoI and CS, researchers have explored other semantic approaches. For instance, Mazza developed notions of observational equivalence for IN libraries and denotational semantics for symmetric interaction combinators.13
These semantic frameworks offer deeper insights into the nature of computation within INs, moving beyond the purely syntactic view of graph rewriting. They provide tools for analysis, comparison, and have directly inspired novel implementation techniques.
3.3. Extended Models
While the standard IN model possesses desirable properties like strong confluence, its inherent determinism limits its ability to directly model phenomena like non-deterministic choice or concurrency. This has motivated the development of various extensions:
* Hard Interaction Systems: Proposed by Lafont, these are a restriction of INs where interaction rules only relabel agents, leaving the underlying graph structure (geometry) unchanged.5 Despite their simplicity (akin to graph relabeling), they are surprisingly powerful and can simulate Turing machines.5 They offer a simplified setting for studying certain computational aspects.
* Non-deterministic INs: Several approaches exist to introduce non-determinism.2 Common methods include:
   * Allowing multiple distinct interaction rules for the same active pair, with the choice of rule applied non-deterministically.17
   * Introducing agents with multiple principal ports (ambiguous agents), where interaction can occur non-deterministically at any connected principal port.2 A specific Amb agent is sometimes used to formalize this.29
   * Permitting edges (wires) that connect more than two ports, introducing branching points.17 These extensions typically sacrifice the strong confluence property of standard INs.28
* Multiport Interaction Nets (MINs): This is arguably the most studied extension for modeling concurrency.28 MINs explicitly allow agents to have multiple principal ports.36 This feature is crucial for encoding the choice mechanisms and complex communication patterns found in process calculi.28 MINs have been shown to be capable of faithfully encoding the full π-calculus 13, demonstrating their power as a model of concurrent computation. Research has explored their semantics, including event structures 28 and GoI models involving multiple tokens.28 A universal system, multiport interaction combinators, has also been defined.28 Studies suggest MINs are strictly more expressive than multi-rule interaction nets (where non-determinism comes only from multiple rules per pair).28
* Differential Interaction Nets: These nets arise from differential linear logic and can be seen as a multi-rule variant of INs.28 They exhibit non-deterministic behavior and have been used to encode finitary fragments of the π-calculus.28 However, some analyses suggest limitations in their ability to fully capture the true concurrency of expressive process calculi.33
* Other Extensions: Researchers have proposed other variations, such as Interaction Automata, which embed INs in a spatial topology 9; Bigraphical Nets, combining INs with Milner's bigraphs to handle both connectivity and locality structure, particularly motivated by encoding the ρ-calculus 15; systems allowing nested pattern matching in rules 37; and extensions incorporating generic rules and types to model impure functions via monads.21
The development of these extensions highlights a crucial point: the core strength of standard INs, their deterministic parallelism guaranteed by strong confluence, is precisely what limits their direct applicability to non-deterministic concurrent systems. Extensions like MINs achieve the necessary expressiveness for concurrency by relaxing the single-principal-port constraint, thereby trading the guarantee of strong confluence for the ability to model choice and concurrent interaction as seen in formalisms like the π-calculus. This represents a fundamental design choice when applying IN-like models to different computational domains.
3.4. Type Systems for Interaction Nets
Type systems provide a way to classify nets and reason about their behavior, ensuring safety and enabling proofs of properties like termination or complexity bounds.
* Lafont's Basic System: The original type system proposed by Lafont is relatively simple.38 It assigns a polarity (+ for output, - for input) and a basic value type (e.g., nat, list, atom) to each port of an agent.4 A net is considered well-typed if agents are used according to their declared types and polarities, and connections are only made between ports of the same value type but opposite polarity (input to output).38 The primary guarantee offered by this system is safety: a well-typed net cannot reduce to a configuration containing a "clash" – an active pair for which no interaction rule is defined due to a type mismatch.4
* Richer Type Systems: Recognizing the limitations of the basic system, researchers have developed more sophisticated type systems aiming for stronger guarantees.39 These often draw inspiration from type systems for lambda calculus and term rewriting:
   * Intersection Types: Systems incorporating type variables, arrow types (→), and intersection types (∩) have been developed to capture more precise behavioral properties.39 These systems often use mechanisms like expansion (creating intersections) and subtyping (lifting).39
   * Sized Types: Inspired by work in functional programming and process calculi, sized types annotate types with size information (often related to data structures or potential computation steps).34 These are particularly useful for complexity analysis, allowing the extraction of bounds on reduction steps or space usage from type derivations.34
   * Deep Inference Types: Leveraging the connection to linear logic, type systems based on deep inference deduction systems have been proposed.30 These systems can provide a more structured view of nets, ensuring correctness and potentially guaranteeing termination under certain conditions.30 They offer a Curry-Howard correspondence between well-formed nets and logical derivations.30
   * Temporal Types: For concurrent extensions of INs (or related models like session-typed processes), type systems incorporating temporal logic modalities (like Next ◯, Always □, Eventually ◊) have been developed to reason about the timing of interactions, message rates, latency, and parallel complexity.42
   * Other Approaches: Simple type systems based on port types have been used to constrain matching in extensions with generic rules.21
* Applications of Typing: The primary goals of these richer type systems extend beyond basic safety. They aim to:
   * Prove termination or normalization for specific classes of nets (e.g., deadlock-free nets).30
   * Perform complexity analysis, deriving bounds on sequential time, parallel time (span), space usage, or combined space-time metrics.30
   * Provide stronger correctness guarantees and structural invariants for programs.4
* Challenges: Designing effective type systems for INs presents unique challenges, particularly because agents and rules are often user-defined.39 The system needs to accommodate this flexibility. Furthermore, compared to the extensive work on type systems for lambda calculus, the development of advanced type systems for the general IN framework is less mature.40
The evolution of type systems for INs reflects a broader trend in programming language research: moving beyond simple static checks towards using types as sophisticated tools for deep program analysis. The initial focus was on preventing basic errors (type clashes), analogous to simple type systems in early programming languages. Subsequent research has incorporated more powerful concepts like intersection types, sized types, and logical frameworks (deep inference) to reason about termination, resource consumption (complexity), and timing, mirroring the development of refinement types, dependent types, and resource-aware type systems in other paradigms. The connection to linear logic provides a particularly fertile ground for developing novel type systems unique to the IN setting.30
3.5. Complexity Analysis
Analyzing the computational complexity (time and space resources) of Interaction Net computations is an active area of research, facilitated by the model's structural properties.
* Cost Models: The linearity property, implying that individual interaction rule applications take constant time, provides a natural basis for cost models.12 Complexity is often measured by the number of interaction steps required to reach a normal form.
* Sequential vs. Parallel Complexity: A key distinction is made between sequential and parallel complexity.18
   * Sequential Time: The total number of interaction steps required when reducing only one active pair at a time.
   * Parallel Time (Span): The number of steps required when all currently available active pairs are reduced simultaneously in each step.18 This measures the time assuming unbounded parallel processing resources. Research investigates when parallel evaluation offers genuine speedups. Some nets are inherently sequential, meaning there is at most one active pair at any given time, and parallel evaluation offers no advantage (e.g., the simple unary addition example).18 Other computations, like calculating Fibonacci numbers recursively, exhibit significant potential for parallel speedup as many independent sub-computations are generated.18 The parallel time complexity is always less than or equal to the sequential time complexity.18
* Techniques for Analysis: Various techniques are employed to derive complexity bounds:
   * Type-Based Analysis: Sophisticated type systems, particularly those incorporating sized types or similar annotations, can be used to extract complexity bounds directly from type derivations.34 Techniques often involve assigning complexity potentials to typed nodes and tracking how these potentials change during reduction.34 This allows for compositional analysis of time, space, and even combined space-time bounds for both sequential and parallel reduction.34
   * Context Semantics: The paths traced by tokens in context semantics can be used to define notions of weight that bound the length (number of steps) of reduction sequences.34
   * Adaptations from Rewriting: Techniques from term rewriting theory, such as dependency pairs and interpretations, have been adapted to analyze the runtime complexity of IN programs, particularly where sharing is crucial.34
   * Session Types (for Concurrent Systems): For concurrent extensions or related message-passing systems, resource-aware session types, often augmented with temporal information, are used to analyze communication costs, latency, and parallel complexity (span).34
* Path-Based Evaluation Complexity: An alternative evaluation method inspired by GoI involves traversing paths through the net using mechanisms like stack machines.31 While potentially avoiding explicit graph manipulation, naive path-based evaluation can suffer exponential slowdown compared to standard reduction.45 However, for specific, restricted classes of nets (e.g., those arising from certain logical fragments or possessing specific structural properties), efficient path-based evaluation strategies exist that achieve logarithmic space or polynomial time complexity.45
* Practical Complexity Considerations: While theoretical analysis focuses on interaction steps, practical performance on real hardware is also a concern. Some anecdotal evidence suggests surprising efficiency for certain algorithms on specific IN encodings (e.g., modular exponentiation on unary numbers encoded via interaction combinators 46). However, concerns remain about the overhead of graph manipulation, particularly pointer chasing in memory, which can hinder performance on conventional architectures.46
The study of complexity in INs highlights both the promise and the nuances of the model. The potential for parallel speedups is evident, but realizing this potential depends heavily on the structure of the specific IN system and the algorithm being implemented. Not all problems benefit from parallelism within this framework.18 Deriving accurate complexity bounds often requires sophisticated analysis techniques, borrowing from type theory, semantics, and rewriting theory.34 Furthermore, there's a distinction between the theoretical step complexity and the practical runtime on physical machines, where implementation overheads can play a significant role.46
4. Implementations and Practical Aspects
Translating the theoretical framework of Interaction Nets into usable software requires interpreters, compilers, abstract machines, and effective implementation techniques. Significant effort has focused on making INs a practical platform for computation, particularly as a target for functional language implementation.
4.1. Evaluators, Abstract Machines, and Compilers
A variety of tools have been developed to execute, visualize, and compile Interaction Nets:
* Interpreters and Visualizers: Several tools focus on interpreting INs and visualizing their reduction. Examples include:
   * Lippi's interpreter, which reads textual net descriptions, displays them graphically, and animates reduction step-by-step.5
   * INblobs, a visual editor and interpreter allowing graphical editing of nets and rules, with options for step-by-step reduction or export.27
   * InterNets, another editor focused on library creation and exporting nets/rules to various formats.47
   * ia2d, an interpreter implementing Interaction Automata (a spatial variant of INs) in Haskell, executing IN programs in parallel on a 2D grid and providing detailed statistics and visualizations.9 These tools are valuable for education, debugging, and gaining intuition about the dynamics of IN reduction.7 Some interpreters also support parallel execution.5
* Abstract Machines: Abstract machines provide a lower-level target for compilation. The Interaction Net Abstract Machine (IAM) was designed as the compilation target for the Pin language.22 It executes a specific instruction set designed for manipulating IN structures (agents, ports, connections).22 The idea of deriving abstract machines directly from token-passing IN encodings has also been proposed, suggesting a systematic way to bridge the gap between high-level strategies and low-level execution.6
* Compilers: Compilers translate IN descriptions or higher-level languages into lower-level representations, such as abstract machine code or even native code.
   * The Pin compiler translates the Pin language into IAM instructions.12 It employs various compilation schemes to handle net definitions, rule definitions, terms, and equations, managing variable bindings and generating code to construct and rewire nets during reduction.22
   * Other implementation efforts mentioned include AMINE, INET, and amineLight, suggesting a lineage of development in IN compilers/evaluators.4 The primary motivation for developing IN compilers is often to leverage potentially efficient (and parallel) IN execution backends for implementing other programming languages, particularly functional ones.6 Compiling a sequential language to INs could potentially yield a parallel implementation "for free".12
4.2. Key Implementation Techniques
Several core techniques underpin efficient and flexible IN implementations:
* Token-Passing: This technique, heavily inspired by Geometry of Interaction and Context Semantics 13, uses special unary agents ("tokens") that traverse the net to control the evaluation process.6 Instead of relying solely on the spontaneous interaction of active pairs, the token dictates where reduction should occur next. This has proven remarkably effective for implementing specific evaluation strategies for lambda calculus within the IN framework, such as:
   * Call-by-name and call-by-value.6
   * Call-by-need.26
   * Optimal reduction.26 A key advantage cited is the simplicity and intuitiveness of the approach, often avoiding the need for complex mechanisms like "boxing" used in earlier encodings.6 The token essentially acts as a control pointer, mimicking the behavior of abstract machines. This technique has also been successfully adapted to embed read-back mechanisms directly within INs, allowing the extraction of a textual representation of the normal form without leaving the formalism.29 Token-passing thus provides a versatile bridge between the declarative rewriting nature of INs and more procedural control flow needed for specific evaluation semantics.
* In-Place Rewriting: This focuses on minimizing memory allocation during reduction by reusing the memory occupied by the agents in an active pair for the agents created in the right-hand side of the rule.8 An algorithm can be considered in-place if it runs using only a small, constant amount of additional memory.8 Analysis of interaction rules, specifically comparing the number of agents on the left-hand side (always two) versus the right-hand side, determines the potential for in-place execution 8:
   * If the RHS has two or fewer agents, the original agents can be directly reused (constant space).
   * If the RHS has more than two agents, extra space is generally needed, but strategic reuse of the original agent nodes can minimize allocation.8 Techniques involve annotating rules to specify node reuse and compiler analysis to automatically detect and optimize for in-place opportunities.8 Examples like unary addition, insertion sort, and list reversal demonstrate algorithms that can be implemented in-place using INs.8
* Handling Locality and Parallelism: Exploiting the inherent parallelism of INs in practice requires sophisticated implementation strategies. This involves managing potentially distributed graph representations, efficiently identifying all active pairs eligible for reduction in a parallel step, scheduling these reductions across multiple processors or cores, and handling communication or data migration if the model incorporates spatial locality (as in Interaction Automata 9). While the theory guarantees correctness without synchronization, achieving efficient speedup requires careful engineering of the runtime system.46
4.3. Programming Languages and Environments for Interaction Nets
While INs can be programmed directly, their graphical nature and low-level interaction rules are often considered primitive for general-purpose programming.7 This has spurred the development of higher-level languages and environments that use INs as their underlying execution model.
* The Need for Abstraction: Raw INs lack features common in modern languages, such as complex data structures, modules, and convenient syntax.10 Analogy is often drawn to programming directly in lambda calculus or assembly language.10
* Pin: Pin was developed as a textual language to provide structure for IN programming.12 It introduces features like named nets (parameterized by free ports), agent variables for defining rule schemas, a module system, and built-in agents for I/O and arithmetic.22 Pin compiles to the IAM abstract machine.22
* iNet / HVM / Formality-Core: These represent more recent efforts focused on creating efficient functional programming languages based directly on INs or Interaction Combinators.20 They often emphasize achieving optimal reduction and exploiting parallelism. Features include native data types (numbers, strings), efforts towards memory efficiency (e.g., constant-space operations like if-then-else), and providing a compilation target for even higher-level languages.49 The goal is to offer a practical functional language with the unique benefits of the interaction net model.
* Juvix: This project aims to integrate dependent linear types with an IN execution model (specifically, optimal reduction).52 The target application is the development of formally verifiable and efficiently executable smart contracts.52
* Interaction Calculus: While a formal language exists 2, it is generally considered too low-level and esoteric for direct programming, serving more as a foundation for semantics and implementation.22
The development of these languages underscores a key trend: INs are increasingly viewed as a powerful intermediate representation or compilation target rather than a primary end-user programming language.6 The goal is to harness the desirable properties of INs (parallelism, optimal reduction, explicit resource management) while providing programmers with more familiar and productive high-level abstractions. The success of INs may depend significantly on the maturity and usability of these overlying languages and their compilers.
However, achieving practical efficiency remains a significant hurdle. Despite the theoretical elegance of constant-time steps and lock-free parallelism, implementations on conventional hardware often struggle with the overhead associated with graph manipulation, particularly the cost of pointer chasing and memory management.46 This suggests a gap between the theoretical potential and realized performance. Overcoming this gap through advanced compilation techniques, optimized runtimes, or perhaps even novel hardware architectures remains a central challenge for the field.46 The ongoing development of systems like HVM indicates continued efforts to tackle this efficiency problem.49
5. Applications of Interaction Nets
Interaction Nets have found applications in various domains, most prominently in the implementation of functional programming languages, but also extending into concurrency theory and more speculative areas like quantum computing and systems biology.
5.1. Functional Programming and Lambda Calculus
This remains the most established and impactful application area for Interaction Nets.
* Optimal Reduction: INs, particularly systems based on interaction combinators, provide a mechanism for implementing optimal reduction strategies for the lambda calculus, following Lévy's notion of optimality which aims to avoid the duplication of computation.2 Lamping's algorithm, a key breakthrough in optimal reduction, was subsequently understood and refined using the formalism of INs.6 Implementations like Lambdascope 2 and more recent approaches using token-passing mechanisms 26 demonstrate the suitability of INs for this task. The graphical nature allows explicit representation of sharing, which is key to optimality. Work in this area also includes embedding read-back mechanisms to translate the resulting net back into a lambda term.29 While optimal reduction is theoretically significant, its practical performance benefits compared to optimized lazy evaluation (like in Haskell) are still debated.31
* Evaluation Strategies: Beyond optimal reduction, INs serve as a versatile framework for implementing various standard evaluation strategies for lambda calculus. Token-passing techniques, in particular, offer elegant encodings for call-by-name, call-by-value 6, and call-by-need 26 without requiring complex machinery like boxes often found in earlier IN encodings.6 INs have also been used to implement efficient closed reduction (reduction of terms without free variables).2
* Efficient Implementation Target: Due to their properties like explicit sharing, potential for parallelism, and mathematically clean semantics, INs are frequently proposed as an intermediate language or compilation target for functional programming languages.6 The idea is that compiling a functional language to an efficient IN evaluator could provide performance benefits, including parallel execution, even for sequentially conceived languages.12 Projects like HVM/Formality aim to realize this potential directly.49
The implementation of lambda calculus, especially optimal reduction, can be considered the historical "killer application" for Interaction Nets. It not only showcased the model's capabilities but also significantly drove the development of its theory (e.g., understanding combinators, developing token-passing) and implementation techniques. Much of the research momentum in INs has been linked to its promise for functional language execution.
5.2. Concurrency Theory
While standard INs are deterministic, their extensions, particularly Multiport Interaction Nets (MINs), have been developed to model concurrent systems.
* Modeling Process Calculi: MINs, which allow agents to have multiple principal ports, provide the necessary mechanism to model the non-deterministic choice inherent in concurrency.28 They have been successfully used to encode process calculi like the full π-calculus, capturing its communication and concurrency patterns.13 Research has focused on ensuring the faithfulness of these encodings, meaning the IN reduction accurately reflects the operational semantics of the process calculus.36 Semantic models for concurrent INs, including event structures and multi-token GoI models, have also been investigated.28
* Expressiveness: The introduction of multiple principal ports significantly increases the expressive power of the model compared to standard INs or extensions based solely on multiple rules.28 Studies have formally compared the expressiveness of different non-deterministic IN variants.33
5.3. Emerging Areas
Interaction Nets have also been proposed or explored, often more speculatively, in other scientific domains.
* Quantum Computing / Information / Physics: Several connections, often drawing on the underlying principles of GoI or the structural properties of INs, have been suggested:
   * GoI and Physics: Girard's GoI itself draws analogies with concepts from physics, and further work has explored connections between proof nets/GoI and quantum field theory formalisms like Feynman diagrams and operator algebras.32 GoI models have also been developed for higher-order quantum computation.33
   * Digital Physics: INs have been proposed as an alternative foundational model for "digital physics," potentially replacing cellular automata.16 Their inherent locality, linearity, and potential for asynchronous ("clockless") computation are seen as potentially aligning better with physical principles than grid-based, often synchronous, CA models.16
   * Superposition: Some recent work explores concepts analogous to superposition within IN frameworks, applying functions to "superposed" inputs, particularly in the context of solving problems like SAT, although the interpretation and computational advantage remain subjects of discussion.51 These connections are intriguing but generally less developed and validated than applications in classical computation.
* Systems Biology / Molecular Computing: The graphical and interaction-based nature of INs resonates with models used in biology:
   * General Network Modeling: INs are mentioned in the context of general biological networks like protein interaction nets or genetic networks, though often just as an example of network formalisms.54
   * Artificial Chemistry: More specific proposals involve designing artificial chemistries based on IN principles. The chemlambda project, for example, uses IN-like graph rewrite rules and explores emergent properties like self-replication (quine graphs), suggesting parallels with molecular interactions.56
   * Biochemical Modeling: Extensions of INs or related calculi have been proposed for modeling molecular structures, reaction patterns, and biochemical networks.36
   * Resource Allocation: INs have been used as a simulation basis for modeling resource allocation dynamics.35 Similar to quantum applications, the use of INs in biology and chemistry appears largely exploratory. While the interaction paradigm seems conceptually fitting, establishing concrete, validated IN-based models that offer significant advantages over existing systems biology formalisms is an ongoing challenge. Projects like chemlambda represent concrete steps in this direction.56
5.4. Other Applications
Interaction Nets have also been used to implement various specific algorithms and simulations:
* Algorithm Implementation: Examples include standard algorithms like sorting (e.g., insertion sort, merge sort, bitonic sort) 8, arithmetic operations (addition, multiplication, Fibonacci) 1, and list processing (reversal, append, finding last element).8 These often serve as benchmarks or illustrations of programming techniques within the IN framework, including in-place computation.8
* Simulations: INs have been used to simulate other computational models, such as 1-dimensional cellular automata 5, or specific systems like resource allocation models.35
* Distributed Systems / IoT: The distributed and asynchronous nature of INs has led to proposals for their use in designing solutions for highly interconnected environments like ad hoc networks, decentralized systems, and the Internet of Things (IoT).35
6. Comparison with Other Computational Models
Understanding the unique characteristics of Interaction Nets requires comparing them with other well-known models of computation.
6.1. Lambda Calculus
Interaction Nets and the lambda calculus offer fundamentally different views of computation. Lambda calculus relies on term substitution (β-reduction) as its core operational step.2 This substitution is typically defined globally on the term structure and implicitly handles resource duplication (when a variable appears multiple times in the function body) and erasure (when a variable does not appear). Garbage collection is usually required in implementations to manage memory.1 In contrast, INs operate via local graph rewriting.1 Resource handling is explicit: duplication and erasure must be performed by specific agents (like δ and ε combinators).1 Reduction steps (interactions) are local and constant-time.1 This makes INs a lower-level, more operational model, exposing the mechanics of sharing and reduction steps that are abstracted away in lambda calculus.6 This explicitness is particularly advantageous for analyzing computational cost and implementing fine-grained control over evaluation, as seen in optimal reduction strategies.29
6.2. Process Calculi (e.g., π-calculus)
Process calculi like the π-calculus are designed specifically to model concurrency and communication, featuring inherent non-determinism (e.g., choice operators, race conditions).28 Standard Interaction Nets, being strongly confluent, are deterministic.2 Therefore, modeling the full behavior of process calculi requires extensions to INs, primarily Multiport Interaction Nets (MINs), which introduce non-determinism by allowing multiple principal ports.13 While MINs can encode the π-calculus, this comes at the cost of losing the strong confluence property that characterizes standard INs.
6.3. General Graph Rewriting Systems
As discussed in Section 2.3, Interaction Nets are a highly restricted subclass of general graph rewriting systems.1 General systems allow rules that can match complex graph patterns and perform arbitrary transformations. INs restrict rules to binary interactions between agents connected at principal ports, enforce linearity (interface preservation), and permit only one rule per agent pair.1 This trade-off sacrifices the generality of arbitrary graph transformations but gains crucial properties like guaranteed strong confluence and locality by construction.4
6.4. Term Rewriting Systems (TRSs)
TRSs, like lambda calculus, operate on term structures. INs can be seen as a graphical implementation technique or operational semantics for TRSs.12 Encodings exist to translate certain classes of TRSs into IN systems.58 The graphical nature of INs allows for explicit sharing of common subterms, potentially leading to more efficient evaluation compared to naive term rewriting.58 Calculi like the ρ-calculus generalize both TRSs and lambda calculus, and INs (or extensions like Bigraphical Nets) have been used to study their operational semantics.15
6.5. Cellular Automata (CA)
Cellular Automata typically operate on a fixed, regular grid structure (e.g., 1D or 2D), with state updates occurring synchronously based on local neighborhood rules.9 Interaction Nets, in contrast, have a flexible, dynamic graph topology.9 While IN reduction is local, the overall structure is not confined to a grid, and computation can proceed asynchronously due to strong confluence.2 Although INs can simulate simple CAs (like 1D CA 5), their fundamental structure and mode of operation are quite different. Extensions like Interaction Automata attempt to bridge this gap by imposing a spatial topology onto INs.9
6.6. Summary Comparison
Interaction Nets occupy a specific position in the landscape of computational models. They are more constrained than general graph rewriting systems, gaining strong formal properties like confluence at the expense of rewriting flexibility. Compared to lambda calculus, they offer a more explicit, operational view, making resource management and reduction steps visible, which is beneficial for implementation and analysis but can make high-level programming more complex. Their inherent determinism contrasts with the non-determinism central to process calculi, necessitating extensions for concurrency modeling. Their dynamic graph structure and asynchronous potential differentiate them from the typically grid-based, synchronous nature of cellular automata. This unique combination of features—graphical representation, local interaction, linearity, strong confluence, and explicit computation steps—defines both their strengths and limitations.
The following table summarizes key comparative aspects:
Table 1: Feature Comparison of Interaction Nets and Related Models


Feature
	Interaction Nets (Standard)
	Lambda Calculus
	Process Calculi (π-calculus)
	General Graph Rewriting
	Cellular Automata
	Determinism (Default)
	Yes 2
	Yes (Church-Rosser)
	No
	No
	Yes (often)
	Confluence
	Strong (Diamond) 2
	Church-Rosser
	No (generally)
	No (generally)
	Yes (often)
	Locality of Reduction
	Yes 2
	No (substitution)
	Yes (communication)
	Variable
	Yes
	Explicitness Copy/Erase
	Yes (needs agents) 1
	No (implicit in substitution)
	Yes (replication)
	Variable
	Yes (state update)
	Inherent Parallelism
	High (confluence/locality) 2
	Limited (strategy-dependent)
	High (by design)
	Variable
	High (grid-based)
	Synchronization
	Not required 2
	Strategy-dependent
	Required (channels)
	Variable
	Often synchronous
	Primary Application
	Func. Lang. Impl. 2
	Func. Prog. Theory
	Concurrency Modeling
	General Transformations
	Simulation, Physics
	Abstraction Level
	Low-Medium (target) 10
	High
	Medium-High
	Variable
	Low-Medium
	7. Challenges, Limitations, and Future Directions
Despite nearly three decades of research, Interaction Nets still face significant challenges, alongside promising avenues for future work.
7.1. Open Problems and Limitations
* Efficiency of Implementations: A persistent and perhaps the most critical limitation is the difficulty in achieving high practical performance, especially on conventional hardware.46 While theoretical cost models based on interaction steps are attractive, the overhead of manipulating graph structures in memory, particularly pointer chasing and dynamic memory management, can negate the benefits of parallelism and constant-time rules.46 Bridging the gap between theoretical step counts and actual wall-clock time remains a major challenge.
* Scalability: Directly related to efficiency, the scalability of IN implementations to very large and complex nets is an ongoing concern. The graph manipulation overhead can become prohibitive as nets grow.
* Higher-Level Programming Abstractions: While progress has been made (e.g., Pin, HVM), INs still lack mature, widely adopted high-level programming languages and development environments comparable to mainstream paradigms.7 Writing complex applications directly in INs or low-level calculi remains cumbersome, hindering broader adoption.10 The ecosystem of libraries, tools, and debuggers is underdeveloped.27
* Concurrency Models: While extensions like MINs provide expressiveness for concurrency 28, their formal semantics, notions of equivalence (like bisimulation 33), and efficient implementation are still areas of active research and refinement. Understanding the precise trade-offs involved in sacrificing confluence for concurrency is crucial.
* Type Systems: Developing practical type systems that are both expressive (capturing properties like termination or complexity) and usable (e.g., with type inference) remains challenging, especially for user-defined agent systems or concurrent/effectful extensions.30
* Formal Verification: There is a relative lack of dedicated tools and established methodologies for formally verifying properties (beyond basic type safety) of IN programs.
7.2. Future Research Directions
Future work aims to address these limitations and further explore the potential of INs:
* Parallel Implementation Techniques: Continued research is essential for developing more efficient runtimes and compilers that can effectively exploit the inherent parallelism of INs on modern multi-core architectures.4 This includes work on garbage collection, optimized graph representations, scheduling strategies, and potentially exploring specialized hardware or compilation to platforms like GPUs or FPGAs.46
* Language Design and Tooling: Further development of high-level programming languages built on INs is crucial for practicality.10 This involves designing better syntax, incorporating advanced features like sophisticated type systems (e.g., dependent or linear types 52), robust module systems 24, and mechanisms for handling computational effects (e.g., via monads 21). Improving development tools, debuggers, and visualizers is also important.27
* Semantics of Concurrent/Extended INs: Deeper theoretical investigation into the operational, denotational, and algebraic semantics of non-deterministic and multiport interaction nets is needed.3 This includes refining notions of behavioral equivalence and understanding their expressiveness limits.33
* New Application Domains: Continued exploration of INs in emerging areas holds potential. This includes further investigating connections to quantum computation 16, developing practical models for systems biology and artificial chemistry 36, exploring applications in AI (e.g., graph-based learning models), reversible computing, and designing robust distributed systems.35
* Integration with Verification Tools: Connecting IN models and languages to existing or new formal verification frameworks (model checkers, theorem provers) would enhance confidence in the correctness of IN-based systems.
* Complexity Theory: Refining complexity analysis techniques for INs, developing methods for automatic complexity inference (perhaps via type systems 34), and better understanding the relationship between theoretical step complexity and practical performance are important ongoing goals.
Ultimately, the central challenge remains bridging the gap between the elegant theory of Interaction Nets and their practical application as an efficient, usable platform for parallel programming. Significant progress in software engineering—encompassing runtimes, compilers, languages, and tools—is required to fully realize the model's potential. Simultaneously, theoretical exploration continues to push the boundaries of the formalism, particularly in understanding concurrency and semantics, suggesting that the foundational aspects of Interaction Nets are still evolving.
8. Conclusion
8.1. Synthesis
Interaction Nets, originating from Lafont's work generalizing Linear Logic proof nets, constitute a unique graphical model of computation based on local graph rewriting. Their defining characteristics are the properties of locality, linearity, and strong confluence, which emerge directly from the constrained nature of their interaction rules. This combination mathematically guarantees deterministic computation and provides a natural foundation for massive parallelism, as reductions can proceed concurrently without interference or the need for explicit synchronization.
8.2. Current Status
The research landscape surrounding Interaction Nets is multifaceted. Theoretical work continues to explore deep connections to logic (Linear Logic) and semantics (Geometry of Interaction, Context Semantics), providing foundational understanding and inspiring implementation techniques. The implementation of functional languages, particularly the lambda calculus, remains a central and highly successful application domain, with INs providing the basis for optimal reduction algorithms and various evaluation strategies. Significant effort has been dedicated to developing practical implementation techniques, such as token-passing for strategy control and in-place rewriting for memory efficiency. Recognizing the low-level nature of raw INs, researchers have developed extensions (like Multiport Interaction Nets for concurrency) and higher-level programming languages (Pin, HVM, Juvix) aiming to make the paradigm more accessible and powerful. Complexity analysis, leveraging type systems and semantic techniques, seeks to quantify the performance characteristics, especially regarding parallel execution. Exploration into emerging domains like quantum physics and systems biology, while often speculative, points towards the perceived generality of the interaction paradigm.
8.3. Strengths and Weaknesses
The core strengths of Interaction Nets lie in their strong theoretical foundation, guaranteed confluence leading to deterministic parallelism, locality of computation, and the explicitness of computational steps which aids in cost modeling and understanding resource usage. However, these strengths are counterbalanced by significant challenges. The low-level, explicit nature of the basic model can make programming complex tasks cumbersome. Achieving practical performance efficiency, especially on conventional hardware, remains a major obstacle due to graph manipulation overheads. While extensions address limitations like determinism, they often sacrifice the original model's strong guarantees and introduce new complexities in semantics and implementation. Furthermore, the ecosystem surrounding INs (languages, tools, libraries) is considerably less mature than those of established programming paradigms.
8.4. Future Outlook
Interaction Nets hold considerable potential as a fundamental model for parallel computation and as an efficient backend for functional and potentially other programming languages. Their unique combination of properties offers a different perspective compared to mainstream models. However, realizing this potential hinges critically on overcoming the practical implementation challenges and developing mature, high-level programming abstractions. Future progress will likely depend on continued innovation in compiler technology, runtime systems (perhaps including specialized hardware), and language design. Further theoretical work is also needed to fully understand the semantics and capabilities of extended IN models, particularly for concurrency. While the path to widespread adoption faces hurdles, the elegance of the core model and its deep connections to logic continue to motivate research into harnessing the power of interaction for computation. The exploration of novel application areas further suggests that the story of Interaction Nets is still unfolding.
Works cited
1. XXIIVV — interaction nets, accessed on April 17, 2025, https://wiki.xxiivv.com/site/interaction_nets.html
2. Interaction nets - Wikipedia, accessed on April 17, 2025, https://en.wikipedia.org/wiki/Interaction_nets
3. lmcs.episciences.org, accessed on April 17, 2025, https://lmcs.episciences.org/1108/pdf
4. An Encoding of Interaction Nets in OCaml, accessed on April 17, 2025, https://joerg.endrullis.de/downloads/gcm2024/STAF_2024_paper_72.pdf
5. universal hard interaction for clockless computation, accessed on April 17, 2025, https://users.polytech.unice.fr/~lippi/r/lippi-clockless.pdf.gz
6. www.lsv.fr, accessed on April 17, 2025, http://www.lsv.fr/Publis/PAPERS/PDF/sinot-tlca05.pdf
7. A Functional Programming Language for Interaction Nets – Abstract, accessed on April 17, 2025, https://plrg-bristol.github.io/fir/assets/abstracts/thatcher.pdf
8. (PDF) In-place Graph Rewriting with Interaction Nets - ResearchGate, accessed on April 17, 2025, https://www.researchgate.net/publication/308009169_In-place_Graph_Rewriting_with_Interaction_Nets
9. cl-informatik.uibk.ac.at, accessed on April 17, 2025, http://cl-informatik.uibk.ac.at/users/sgimenez/data/articles/ia2d.pdf
10. (PDF) Towards a Programming Language for Interaction Nets - ResearchGate, accessed on April 17, 2025, https://www.researchgate.net/publication/222918925_Towards_a_Programming_Language_for_Interaction_Nets
11. Explanation of a simple example of how an interaction net computes?, accessed on April 17, 2025, https://cs.stackexchange.com/questions/160537/explanation-of-a-simple-example-of-how-an-interaction-net-computes
12. Interaction nets: programming language design and implementation - CiteSeerX, accessed on April 17, 2025, https://citeseerx.ist.psu.edu/document?repid=rep1&type=pdf&doi=fc2598c9d7ad0a1f2e5777bcfcbc00366c3d579e
13. (PDF) On Context Semantics and Interaction Nets - ResearchGate, accessed on April 17, 2025, https://www.researchgate.net/publication/266659046_On_Context_Semantics_and_Interaction_Nets
14. Partial Evaluation of Interaction Nets., accessed on April 17, 2025, http://pagesperso.ls2n.fr/~bechet-d/Documents/LIENS-1992-Bec-WSA92-recompiled-2003-07-22-draft.pdf
15. (PDF) Interaction Nets vs. the ρ-calculus: Introducing Bigraphical Nets - ResearchGate, accessed on April 17, 2025, https://www.researchgate.net/publication/222823685_Interaction_Nets_vs_the_r-calculus_Introducing_Bigraphical_Nets
16. [1702.03523] A better model of computation for digital physics? - arXiv, accessed on April 17, 2025, https://arxiv.org/abs/1702.03523
17. 8 - Interaction nets Flashcards | Quizlet, accessed on April 17, 2025, https://quizlet.com/899016662/8-interaction-nets-flash-cards/
18. Parallel evaluation of interaction nets: some observations and examples - CEUR-WS.org, accessed on April 17, 2025, https://ceur-ws.org/Vol-1403/paper5.pdf
19. Live Science | Introduction to Interaction Nets - YouTube, accessed on April 17, 2025, https://www.youtube.com/watch?v=zCcAg-vcpys
20. Interaction Nets, Combinators, and Calculus, accessed on April 17, 2025, https://zicklag.github.io/blog/interaction-nets-combinators-calculus/
21. Realizing Monads in Interaction Nets via Generic Typed Rules - Theory and Logic Group - TU Wien, accessed on April 17, 2025, https://www.logic.tuwien.ac.at/people/gramlich/papers/techrep-e1852-2011-01.pdf
22. (PDF) Interaction nets: programming language design and ..., accessed on April 17, 2025, https://www.researchgate.net/publication/220054026_Interaction_nets_programming_language_design_and_implementation
23. A Calculus for Interaction Nets - CiteSeerX, accessed on April 17, 2025, https://citeseerx.ist.psu.edu/document?repid=rep1&type=pdf&doi=e0b35e17d680da34afef2f324c0f3e8b4519639f
24. Interaction nets: programming language design and implementation, accessed on April 17, 2025, https://www.user.tu-berlin.de/o.runge/tfs/workshops/gtvmt08/Program/paper_38.pdf
25. A context semantics for interaction nets, accessed on April 17, 2025, https://dice14.tcs.ifi.lmu.de/abstracts/Perrinel.pdf
26. A token-passing net implementation of optimal reduction with embedded read-back, accessed on April 17, 2025, https://www.semanticscholar.org/paper/A-token-passing-net-implementation-of-optimal-with-Salikhmetov/c84d2ec72489785c215846ef6603abe03f13ae34
27. A Tool for Programming with Interaction Nets - Universidade do Minho, accessed on April 17, 2025, https://webarchive.di.uminho.pt/wiki.di.uminho.pt/twiki/pub/Research/PURe/PURePublications/PUReTR060401.pdf
28. The Geometry of Concurrent Interaction: Handling Multiple Ports by Way of Multiple Tokens (Long Version) - arXiv, accessed on April 17, 2025, https://arxiv.org/pdf/1704.04620
29. arxiv.org, accessed on April 17, 2025, https://arxiv.org/pdf/1512.02995
30. The Structure of Interaction - DROPS, accessed on April 17, 2025, https://drops.dagstuhl.de/storage/00lipics/lipics-vol023-csl2013/LIPIcs.CSL.2013.316/LIPIcs.CSL.2013.316.pdf
31. Geometry of interaction and optimal reduction - Boxbase, accessed on April 17, 2025, https://boxbase.org/entries/2019/dec/16/gol-reduction/
32. Proof Nets as Formal Feynman Diagrams - Richard Blute, accessed on April 17, 2025, https://richardblute.ca/wp-content/uploads/2021/08/phi_calc.pdf
33. [PDF] The geometry of concurrent interaction: Handling multiple ports by way of multiple tokens | Semantic Scholar, accessed on April 17, 2025, https://www.semanticscholar.org/paper/c932a812d22331b43b3f3f8bf501e6b778da663b
34. [PDF] The complexity of interaction - Semantic Scholar, accessed on April 17, 2025, https://www.semanticscholar.org/paper/The-complexity-of-interaction-Gimenez-Moser/509d7943d5e1bb9dacbfa9427ab953f6188701e4
35. Interaction Net as a Representation Model of a Programming Language | Request PDF, accessed on April 17, 2025, https://www.researchgate.net/publication/330446536_Interaction_Net_as_a_Representation_Model_of_a_Programming_Language
36. (PDF) Non-deterministic Interaction Nets - ResearchGate, accessed on April 17, 2025, https://www.researchgate.net/publication/238799226_Non-deterministic_Interaction_Nets
37. An Implementation of Nested Pattern Matching in Interaction Nets - arXiv, accessed on April 17, 2025, https://arxiv.org/pdf/1003.4562
38. Interaction Nets - School of Computing Science, accessed on April 17, 2025, https://www.dcs.gla.ac.uk/~simon/publications/diploma.pdf
39. Type assignment and termination of interaction nets - Cambridge University Press & Assessment, accessed on April 17, 2025, https://www.cambridge.org/core/services/aop-cambridge-core/content/view/60CE451F3E7C6FB033DB2266A786D8D5/S0960129598002679a.pdf/type_assignment_and_termination_of_interaction_nets.pdf
40. type theory - Is there a "lambda cube" for interaction nets?, accessed on April 17, 2025, https://cstheory.stackexchange.com/questions/33719/is-there-a-lambda-cube-for-interaction-nets
41. (PDF) The complexity of interaction - ResearchGate, accessed on April 17, 2025, https://www.researchgate.net/publication/301274047_The_complexity_of_interaction
42. Parallel Complexity Analysis with Temporal Session Types - Ankush Das, accessed on April 17, 2025, https://ankushdas.github.io/docs/icfp18.pdf
43. Parallel Complexity Analysis with Temporal Session Types - CMU School of Computer Science, accessed on April 17, 2025, https://www.cs.cmu.edu/~janh/assets/pdf/DasHP18.pdf
44. [PDF] The Complexity of Interaction ( Extended Abstract ) | Semantic, accessed on April 17, 2025, https://www.semanticscholar.org/paper/The-Complexity-of-Interaction-(-Extended-Abstract-)-Gimenez-Moser/f85bcaddfc41880d38c45647057096839489dc4a
45. Is it possible to evaluate interaction combinators efficiently using a path-traveling strategy?, accessed on April 17, 2025, https://cstheory.stackexchange.com/questions/32834/is-it-possible-to-evaluate-interaction-combinators-efficiently-using-a-path-trav
46. Why the overall lack of interest in Interaction Combinators? : r/haskell - Reddit, accessed on April 17, 2025, https://www.reddit.com/r/haskell/comments/568gtk/why_the_overall_lack_of_interest_in_interaction/
47. InterNets: Interactive Design and Execution of Interaction Nets - CiteSeerX, accessed on April 17, 2025, https://citeseerx.ist.psu.edu/document?repid=rep1&type=pdf&doi=3116b4024850ca8a912067c22b478b6a095d253b
48. [1512.02995] A token-passing net implementation of optimal reduction with embedded read-back - arXiv, accessed on April 17, 2025, https://arxiv.org/abs/1512.02995
49. New tool for exploring optimal reductions : r/haskell - Reddit, accessed on April 17, 2025, https://www.reddit.com/r/haskell/comments/bp55ua/new_tool_for_exploring_optimal_reductions/
50. Show HN: iNet – A programming language for interaction nets - Hacker News, accessed on April 17, 2025, https://news.ycombinator.com/item?id=37406742
51. We can solve 3-SAT "quickly" by using superpositions on interaction nets : r/haskell - Reddit, accessed on April 17, 2025, https://www.reddit.com/r/haskell/comments/192mrgj/we_can_solve_3sat_quickly_by_using_superpositions/
52. Juvix: dependent-linearly-typed core language with optimal reduction and interaction nets : r/ProgrammingLanguages - Reddit, accessed on April 17, 2025, https://www.reddit.com/r/ProgrammingLanguages/comments/cziho3/juvix_dependentlinearlytyped_core_language_with/
53. Vine: A programming language based on Interaction Nets | Hacker News, accessed on April 17, 2025, https://news.ycombinator.com/item?id=43144040
54. Binder – Omics bioinformatics for health and systems biology - IZBI, accessed on April 17, 2025, https://www.izbi.uni-leipzig.de/science/research-groups/binder/
55. Reconstructing the topology of sparsely-connected dynamical networks - Mathematical Sciences, accessed on April 17, 2025, https://math.gmu.edu/~tsauer/pre/reprints/nettop.pdf
56. [PDF] Molecular computers | Semantic Scholar, accessed on April 17, 2025, https://www.semanticscholar.org/paper/Molecular-computers-Buliga/21763881658fd9a479fc8e22736a7d312d737a52
57. Artificial chemistry experiments with chemlambda, lambda calculus, interaction combinators - Institute of Mathematics of the Romanian Academy, accessed on April 17, 2025, http://imar.ro/~mbuliga/chemlambda-github/quine-graph-doc.pdf
58. Term Rewriting as Interaction Nets Plus Hyperedge Replacement - CiteSeerX, accessed on April 17, 2025, https://citeseerx.ist.psu.edu/document?repid=rep1&type=pdf&doi=24b9053789157c3baef3f5c38d6108a7314e81ad